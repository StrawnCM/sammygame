<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Canyon Math Shooter</title>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; cursor:crosshair; }
    #gameCanvas { display:block; background:#000; }

    /* === UI === */
    #ui {
      position:absolute; top:10px; left:10px; color:#00ff00; font-size:18px; text-shadow:0 0 10px #00ff00; font-weight:bold;
      background:rgba(0,0,0,0.5); border:2px solid #00ff00; padding:8px 10px; border-radius:6px; user-select:none; z-index:5;
    }
    #ui .row { margin:3px 0; }
    #ui label { font-weight:bold; margin-right:6px; }
    #speedSlider { vertical-align:middle; }
    #speedLabel { display:inline-block; min-width:42px; text-align:right; margin-left:6px; }

    /* === Start screen === */
    #startScreen {
      position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.98) 60%, rgba(0,0,0,1) 100%);
      color:#ff9; text-align:center; z-index:10;
      border: 3px solid #ff9; box-shadow:0 0 40px #ff9 inset, 0 0 60px #f80;
    }
    #startScreen h1 {
      font-size:64px; margin:0 0 8px 0; letter-spacing:2px; color:#fff3aa;
      text-shadow: 0 0 6px #ff9900, 0 0 18px #ff6600, 0 0 36px #ff3300;
    }
    #startScreen h2 { margin:0 0 24px 0; color:#ffa; font-weight:normal; }
    #startBtn {
      background:#ff9900; color:#000; border:none; padding:14px 26px; font-size:20px; font-weight:bold; cursor:pointer;
      box-shadow:0 0 20px #ff9900; border-radius:6px;
    }
    #startBtn:hover { background:#ffaa22; }

    /* === Math prompt === */
    #mathPrompt {
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.9); border:3px solid #00ff00; padding:20px; color:#00ff00; text-align:center; display:none;
      box-shadow:0 0 20px #00ff00; max-width:90%; z-index:6;
    }
    #mathPrompt h2 { margin:0 0 12px 0; font-size:22px; }
    #mathPrompt .q { font-size:36px; margin:16px 0 12px; }
    #mathPrompt input {
      background:#000; border:2px solid #00ff00; color:#00ff00; font-size:24px; padding:10px; width:120px; text-align:center;
      font-family:'Courier New', monospace;
    }
    #mathPrompt button {
      background:#00ff00; color:#000; border:none; padding:10px 20px; font-size:18px; margin-left:10px; cursor:pointer;
      font-family:'Courier New', monospace; font-weight:bold;
    }
    #mathPrompt button:hover { background:#00cc00; }

    /* === Overlays === */
    .overlay {
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      background:rgba(0,0,0,0.9); padding:28px; text-align:center; display:none; min-width:300px; z-index:7;
    }
    #gameOver { border:3px solid #ff0000; color:#ff0000; box-shadow:0 0 30px #ff0000; }
    #gameOver h2 { font-size:36px; margin:0 0 14px 0; }
    #gameOver button { background:#ff0000; color:#fff; border:none; padding:14px 26px; font-size:18px; cursor:pointer; font-weight:bold; }

    #youWin { border:3px solid #00ff66; color:#00ff66; box-shadow:0 0 30px #00ff66; }
    #youWin h2 { font-size:36px; margin:0 0 14px 0; }
    #youWin button { background:#00ff66; color:#000; border:none; padding:14px 26px; font-size:18px; cursor:pointer; font-weight:bold; }

    #pauseScreen { border:3px solid #00ffff; color:#00ffff; box-shadow:0 0 30px #00ffff; }
    #pauseScreen button { background:#00ffff; color:#000; border:none; padding:14px 26px; font-size:18px; cursor:pointer; font-weight:bold; }

    #levelBanner {
      position:absolute; top:50px; left:50%; transform:translateX(-50%);
      padding:10px 16px; border:2px solid #00ffcc; color:#00ffcc; background:rgba(0,0,0,0.75);
      font-weight:bold; display:none; text-shadow:0 0 10px #00ffcc; z-index:5;
    }

    #shopScreen {
      border:3px solid #ffaa33; color:#ffaa33; box-shadow:0 0 30px #ffaa33;
      display:flex; flex-direction:column; align-items:center; gap:8px;
    }
    #shopScreen h2 { margin-top:0; margin-bottom:12px; }
    #shopScreen #shopCoins { align-self:flex-start; }
    #shopScreen #shopItems { margin:14px 0; display:flex; flex-direction:column; gap:10px; width:100%; max-width:360px; }
    #shopScreen button { background:#ffaa33; color:#000; border:none; padding:12px 20px; font-size:16px; cursor:pointer; font-weight:bold; }
    #shopScreen > button { align-self:center; margin-top:8px; }
    #shopScreen button:disabled { background:#553300; color:#aa8855; cursor:not-allowed; }
    #shopScreen .item {
      border:2px solid #ffaa33; padding:10px; background:rgba(0,0,0,0.6); text-align:left; display:flex; flex-direction:column; gap:6px;
    }
    #shopScreen .item header { display:flex; justify-content:space-between; align-items:center; font-weight:bold; }
    #shopScreen .item p { margin:0; font-size:14px; color:#ffddaa; }

    #ui button.small {
      background:#ff3333; color:#fff; border:none; padding:4px 10px; font-size:14px; cursor:pointer; font-weight:bold;
    }
    #ui button.small:hover { background:#ff5555; }

    /* Subtle hide crosshair on 2D ship levels; we toggle a class on <body> */
    body.ship-mode { cursor:none; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- START SCREEN -->
  <div id="startScreen">
    <h1>Sammy's Game</h1>
    <h2>Math, Monsters, and Neon Mayhem</h2>
    <button id="startBtn">Start</button>
  </div>

  <!-- HUD -->
  <div id="ui">
    <div class="row">Score: <span id="score">0</span></div>
    <div class="row">Bullets: <span id="bullets">10</span></div>
    <div class="row">Coins: <span id="coins">0</span></div>
    <div class="row">Health: <span id="health">100</span></div>
    <div class="row">Lives: <span id="lives">❤️❤️❤️</span></div>
    <div class="row">Level: <span id="level">1</span>/4</div>
    <div class="row">Progress: <span id="progress">0</span>/<span id="levelGoal">0</span></div>
    <div class="row">Weapon: <span id="weaponName">Basic Blaster</span></div>
    <div class="row" id="nukeRow" style="display:none; gap:6px; align-items:center;">
      Nukes: <span id="nukeCount">0</span>
      <button id="useNukeBtn" class="small">Detonate</button>
    </div>
    <div class="row">
      <label for="speedSlider">Speed</label>
      <input type="range" id="speedSlider" min="0.25" max="2" step="0.05" value="0.50">
      <span id="speedLabel">0.5x</span>
    </div>
  </div>

  <!-- Math reload -->
  <div id="mathPrompt">
    <h2 id="promptTitle">RELOAD — Level 1: Addition</h2>
    <div id="mathQuestion" class="q"></div>
    <input type="number" id="mathAnswer" inputmode="numeric" autocomplete="off" />
    <button id="answerBtn">Fire!</button>
  </div>

  <!-- End screens -->
  <div id="gameOver" class="overlay">
    <h2>GAME OVER</h2>
    <div>Final Score: <span id="finalScore">0</span></div>
    <button id="restartBtn1">Play Again</button>
  </div>

  <div id="youWin" class="overlay">
    <h2>YOU BEAT THE GAME!</h2>
    <div>Final Score: <span id="finalWinScore">0</span></div>
    <button id="restartBtn2">Play Again</button>
  </div>

  <div id="pauseScreen" class="overlay">
    <h2>PAUSED</h2>
    <button id="resumeBtn">Resume</button>
  </div>

  <div id="levelBanner"></div>

  <div id="shopScreen" class="overlay">
    <h2>SUPPLY SHOP</h2>
    <div id="shopCoins">Coins: 0</div>
    <div id="shopItems"></div>
    <button id="shopContinueBtn">Continue</button>
  </div>

  <script>
    // ===== Canvas setup =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      vanishingPoint.x = canvas.width / 2;
      vanishingPoint.y = canvas.height / 2;
      initDecor();
      initStars(); // for level 4 background sizing
      clampPlayer();
    }
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const vanishingPoint = { x: canvas.width / 2, y: canvas.height / 2 };

    // ===== UI elements =====
    const scoreEl = document.getElementById('score');
    const bulletsEl = document.getElementById('bullets');
    const coinsEl = document.getElementById('coins');
    const healthEl = document.getElementById('health');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const progressEl = document.getElementById('progress');
    const levelGoalEl = document.getElementById('levelGoal');
    const weaponNameEl = document.getElementById('weaponName');
    const nukeRow = document.getElementById('nukeRow');
    const nukeCountEl = document.getElementById('nukeCount');
    const useNukeBtn = document.getElementById('useNukeBtn');
    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');
    const mathPrompt = document.getElementById('mathPrompt');
    const promptTitle = document.getElementById('promptTitle');
    const mathQuestionEl = document.getElementById('mathQuestion');
    const mathAnswerEl = document.getElementById('mathAnswer');
    const answerBtn = document.getElementById('answerBtn');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const youWinEl = document.getElementById('youWin');
    const finalWinScoreEl = document.getElementById('finalWinScore');
    const restartBtn1 = document.getElementById('restartBtn1');
    const restartBtn2 = document.getElementById('restartBtn2');
    const levelBanner = document.getElementById('levelBanner');
    const startScreen = document.getElementById('startScreen');
    const startBtn = document.getElementById('startBtn');
    const pauseScreen = document.getElementById('pauseScreen');
    const resumeBtn = document.getElementById('resumeBtn');
    const shopScreen = document.getElementById('shopScreen');
    const shopCoinsEl = document.getElementById('shopCoins');
    const shopItemsEl = document.getElementById('shopItems');
    const shopContinueBtn = document.getElementById('shopContinueBtn');

    // ===== Game state =====
    let score = 0;
    const bulletsPerReload = 10;
    let bullets = bulletsPerReload;
    let coins = 0;
    let health = 100;
    let lives = 3;
    const heartSpawnInterval = 5; // seconds between heart drops
    const coinsPerLevel = 10;
    const coinChestReward = { min: 5, max: 50 };
    const coinChestSpawnRates = { canyon: 0.12, twoD: 0.10 };

    let currentWeapon = 'blaster';
    const ownedWeapons = new Set(['blaster']);
    let nukeCount = 0;
    let pendingLevel = null;

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    let targets = [];      // Level-1 (3D) enemies
    let explosions = [];
    let hearts = [];
    let coinChests3D = [];
    let coinChests2D = [];
    let heartSpawnActive = false;
    let heartSpawnTimer = 0;
    let currentMathProblem = null;
    let isReloading = false;
    let gameRunning = false; // start on title screen
    let isPaused = false;

    // Levels & progression
    let level = 1;
    const maxLevel = 4;
    let levelGoal = 0; // correct answers needed per level (set in configureLevel)
    let correctThisLevel = 0;

    // Speed control (sync to slider at startup)
    let speedMultiplier = 1;

    // Frame timer for framerate-independent motion
    let lastTime = 0; // ms timestamp from rAF

    // ===== Helpers =====
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } // inclusive
    function randRange(min, max) { return Math.random() * (max - min) + min; }
    function clamp(val, a, b){ return Math.max(a, Math.min(b, val)); }

    // ===== Modes (how a level behaves) =====
    const Modes = { CANYON:'canyon', BATS:'bats', JELLIES:'jellies', ALIENS:'aliens' };
    let currentMode = Modes.CANYON;

    // Per-level math label + symbol
    const levelOps = {
      1: { sym: '+', name: 'Addition' },
      2: { sym: '−', name: 'Subtraction' },
      3: { sym: '×', name: 'Multiplication' },
      4: { sym: '×', name: 'Galactic Multiplication' }
    };

    const weaponCatalog = {
      blaster: {
        id: 'blaster',
        name: 'Basic Blaster',
        cost: 0,
        bulletCost: 1,
        description: 'Reliable single-shot laser.',
        hitscanShots: (x, y) => [{ x, y, pierce: 1 }],
        projectiles: (player) => [new Bullet({ x: player.x, y: player.y + (player.bulletDir > 0 ? 12 : -12), dir: player.bulletDir })]
      },
      rifle: {
        id: 'rifle',
        name: 'Plasma Rifle',
        cost: 20,
        bulletCost: 1,
        description: 'Piercing beam slices through two enemies.',
        hitscanShots: (x, y) => [{ x, y, pierce: 2 }],
        projectiles: (player) => [new Bullet({ x: player.x, y: player.y + (player.bulletDir > 0 ? 12 : -12), dir: player.bulletDir, speed: 820, r: 3, damage: 2 })]
      },
      shotgun: {
        id: 'shotgun',
        name: 'Scatter Shotgun',
        cost: 30,
        bulletCost: 3,
        description: 'Three bolt spread. Eats extra ammo but melts crowds.',
        hitscanShots: (x, y) => [
          { x: x - 25, y: y - 20, pierce: 1 },
          { x, y, pierce: 1 },
          { x: x + 25, y: y - 20, pierce: 1 }
        ],
        projectiles: (player) => {
          const baseY = player.y + (player.bulletDir > 0 ? 12 : -12);
          return [
            new Bullet({ x: player.x - 18, y: baseY, dir: player.bulletDir, vx: -180, damage: 1, speed: 560, r: 3.5 }),
            new Bullet({ x: player.x, y: baseY, dir: player.bulletDir, vx: 0, damage: 1, speed: 560, r: 3.5 }),
            new Bullet({ x: player.x + 18, y: baseY, dir: player.bulletDir, vx: 180, damage: 1, speed: 560, r: 3.5 })
          ];
        }
      },
      x2boomgun: {
        id: 'x2boomgun',
        name: 'X2 Boomgun',
        cost: 45,
        bulletCost: 2,
        description: 'Sniper laser fires twin super-charged bolts.',
        hitscanShots: (x, y) => [
          { x, y, pierce: 2 },
          { x, y, pierce: 2 }
        ],
        projectiles: (player) => {
          const baseY = player.y + (player.bulletDir > 0 ? 10 : -10);
          return [
            new Bullet({ x: player.x - 6, y: baseY, dir: player.bulletDir, speed: 980, r: 3, damage: 2 }),
            new Bullet({ x: player.x + 6, y: baseY, dir: player.bulletDir, speed: 980, r: 3, damage: 2 })
          ];
        }
      },
      minigun: {
        id: 'minigun',
        name: 'Mini Gun / Machinegun',
        cost: 60,
        bulletCost: 2,
        description: 'Machinegun stream of bolts. Great for screens full of foes.',
        hitscanShots: (x, y) => [
          { x: x - 18, y, pierce: 1 },
          { x: x - 4, y: y - 8, pierce: 1 },
          { x: x + 4, y: y + 8, pierce: 1 },
          { x: x + 18, y, pierce: 1 }
        ],
        projectiles: (player) => {
          const baseY = player.y + (player.bulletDir > 0 ? 10 : -10);
          return [
            new Bullet({ x: player.x - 18, y: baseY, dir: player.bulletDir, vx: -120, damage: 1, speed: 760, r: 3 }),
            new Bullet({ x: player.x - 6, y: baseY, dir: player.bulletDir, vx: -30, damage: 1, speed: 760, r: 3 }),
            new Bullet({ x: player.x + 6, y: baseY, dir: player.bulletDir, vx: 30, damage: 1, speed: 760, r: 3 }),
            new Bullet({ x: player.x + 18, y: baseY, dir: player.bulletDir, vx: 120, damage: 1, speed: 760, r: 3 })
          ];
        }
      }
    };

    const shopItems = [
      weaponCatalog.rifle,
      weaponCatalog.shotgun,
      weaponCatalog.x2boomgun,
      weaponCatalog.minigun,
      { id: 'nuke', name: 'Omega Nuke', cost: 100, description: 'Instantly vaporizes everything on screen.', type: 'nuke' }
    ];

    // Hardcoded question sets for each level
    const levelQuestions = {
      1: [
        { a:6, b:5, op:'+', answer:11 },
        { a:7, b:4, op:'+', answer:11 },
        { a:7, b:5, op:'+', answer:12 },
        { a:7, b:6, op:'+', answer:13 },
        { a:8, b:3, op:'+', answer:11 },
        { a:8, b:4, op:'+', answer:12 },
        { a:8, b:5, op:'+', answer:13 },
        { a:8, b:6, op:'+', answer:14 },
        { a:8, b:7, op:'+', answer:15 },
        { a:9, b:3, op:'+', answer:12 },
        { a:9, b:4, op:'+', answer:13 },
        { a:9, b:5, op:'+', answer:14 },
        { a:9, b:6, op:'+', answer:15 },
        { a:9, b:7, op:'+', answer:16 },
        { a:9, b:8, op:'+', answer:17 }
      ],
      2: [
        { a:11, b:2, op:'−', answer:9 },
        { a:11, b:3, op:'−', answer:8 },
        { a:11, b:4, op:'−', answer:7 },
        { a:11, b:5, op:'−', answer:6 },
        { a:11, b:6, op:'−', answer:5 },
        { a:11, b:7, op:'−', answer:4 },
        { a:11, b:8, op:'−', answer:3 },
        { a:11, b:9, op:'−', answer:2 },
        { a:12, b:3, op:'−', answer:9 },
        { a:12, b:4, op:'−', answer:8 },
        { a:12, b:5, op:'−', answer:7 },
        { a:12, b:7, op:'−', answer:5 },
        { a:12, b:8, op:'−', answer:4 },
        { a:12, b:9, op:'−', answer:3 },
        { a:13, b:4, op:'−', answer:9 },
        { a:13, b:5, op:'−', answer:8 },
        { a:13, b:6, op:'−', answer:7 },
        { a:13, b:7, op:'−', answer:6 },
        { a:13, b:8, op:'−', answer:5 },
        { a:13, b:9, op:'−', answer:4 },
        { a:14, b:5, op:'−', answer:9 },
        { a:14, b:6, op:'−', answer:8 },
        { a:14, b:8, op:'−', answer:6 },
        { a:14, b:9, op:'−', answer:5 },
        { a:15, b:6, op:'−', answer:9 },
        { a:15, b:7, op:'−', answer:8 },
        { a:15, b:8, op:'−', answer:7 },
        { a:15, b:9, op:'−', answer:6 },
        { a:16, b:7, op:'−', answer:9 },
        { a:16, b:9, op:'−', answer:7 },
        { a:17, b:8, op:'−', answer:9 },
        { a:17, b:9, op:'−', answer:8 }
      ],
      3: [
        { a:6, b:6, op:'×', answer:36 },
        { a:6, b:7, op:'×', answer:42 },
        { a:6, b:8, op:'×', answer:48 },
        { a:6, b:9, op:'×', answer:54 },
        { a:6, b:12, op:'×', answer:72 },
        { a:7, b:7, op:'×', answer:49 },
        { a:7, b:8, op:'×', answer:56 },
        { a:7, b:9, op:'×', answer:63 },
        { a:7, b:12, op:'×', answer:84 },
        { a:8, b:8, op:'×', answer:64 },
        { a:8, b:9, op:'×', answer:72 },
        { a:8, b:12, op:'×', answer:96 },
        { a:9, b:9, op:'×', answer:81 },
        { a:9, b:12, op:'×', answer:108 },
        { a:12, b:12, op:'×', answer:144 }
      ],
      4: [
        { a:4, b:11, op:'×', answer:44 },
        { a:4, b:12, op:'×', answer:48 },
        { a:5, b:11, op:'×', answer:55 },
        { a:5, b:12, op:'×', answer:60 },
        { a:6, b:11, op:'×', answer:66 },
        { a:6, b:12, op:'×', answer:72 },
        { a:7, b:11, op:'×', answer:77 },
        { a:7, b:12, op:'×', answer:84 },
        { a:8, b:11, op:'×', answer:88 },
        { a:8, b:12, op:'×', answer:96 },
        { a:9, b:11, op:'×', answer:99 },
        { a:9, b:12, op:'×', answer:108 },
        { a:10, b:11, op:'×', answer:110 },
        { a:10, b:12, op:'×', answer:120 },
        { a:11, b:11, op:'×', answer:121 },
        { a:11, b:12, op:'×', answer:132 },
        { a:12, b:11, op:'×', answer:132 },
        { a:12, b:12, op:'×', answer:144 }
      ]
    };

    const questionIndex = { 1:0, 2:0, 3:0, 4:0 };

    function shuffleQuestionsForLevel(lvl) {
      const arr = levelQuestions[lvl];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // ===== Difficulty pacing per level =====
    // Level 1 (3D) keeps your original pacing
    const level1Params = { speedRange: [0.20, 0.35], spawnPerSec: 0.60, zStart: 360 };

    // ==== NEW: 2D mode parameters (pixels/second) ====
    const level2Params = { // Bat Cave
      spawnPerSec: 0.55,       // was 0.85 → fewer bats overall
      vyRange: [120, 180],
      ampRange: [30, 70],
      freqRange: [0.6, 1.1],   // was 1.2–2.0 → slower left-right sway
      hp: 1,
      touchDamage: 10
    };
    const level3Params = { // Swamp/Underwater (rise up)
      spawnPerSec: 1.0,
      vyRange: [90, 140],     // upward speed
      driftRange: [-40, 40],  // gentle sideways drift
      hp: 2,                  // tougher
      touchDamage: 12
    };
    const level4Params = { // Space + Boss
      spawnPerSec: 1.15,
      vyRange: [150, 220],
      ampRange: [40, 90],
      freqRange: [1.5, 2.8],
      hp: 1,
      bossHP: 14,
      bossSpeed: 120,
      touchDamage: 12
    };

    function showBanner(text, ms=1200) {
      levelBanner.textContent = text;
      levelBanner.style.display = 'block';
      setTimeout(() => levelBanner.style.display = 'none', ms);
    }
    function syncSpeedFromSlider() {
      speedMultiplier = parseFloat(speedSlider.value);
      speedLabel.textContent = speedMultiplier.toFixed(1) + 'x';
    }

    function updateUI() {
      if (health <= 0 && lives > 0) {
        lives--;
        if (lives > 0) {
          health = 100;
        } else if (gameRunning) {
          gameOver();
        }
      }
      scoreEl.textContent = score;
      bulletsEl.textContent = bullets;
      coinsEl.textContent = coins;
      healthEl.textContent = Math.max(0, health);
      livesEl.innerHTML = '❤️'.repeat(lives);
      levelEl.textContent = level;
      progressEl.textContent = correctThisLevel;
      levelGoalEl.textContent = levelGoal;
      const weapon = weaponCatalog[currentWeapon];
      weaponNameEl.textContent = weapon ? weapon.name : 'Unknown';
      nukeCountEl.textContent = nukeCount;
      nukeRow.style.display = nukeCount > 0 ? 'flex' : 'none';
    }
    function grantChestCoins(x, y) {
      const reward = randInt(coinChestReward.min, coinChestReward.max);
      coins += reward;
      updateUI();
      explosions.push(new Explosion(x, y));
      showBanner(`Loot Chest: +${reward} coins!`, 1100);
    }
    function opForLevel(lvl) { return levelOps[lvl].sym; }

    function generateMathProblemForLevel(lvl) {
      const list = levelQuestions[lvl];
      const idx = questionIndex[lvl];
      if (!list || idx >= list.length) return null;
      return list[idx];
    }

    function showMathPrompt() {
      if (isReloading) return;
      if (questionIndex[level] >= levelQuestions[level].length) {
        bullets = bulletsPerReloadForLevel(level);
        updateUI();
        return;
      }
      isReloading = true;
      currentMathProblem = generateMathProblemForLevel(level);
      promptTitle.textContent = `RELOAD — Level ${level}: ${levelOps[level].name}`;
      mathQuestionEl.innerHTML = `${currentMathProblem.a} ${currentMathProblem.op} ${currentMathProblem.b} = ?`;
      mathPrompt.style.display = 'block';
      mathAnswerEl.value = '';
      mathAnswerEl.focus();
    }

    // Boss gate: on level 4, after you've hit the goal once, we spawn a boss and
    // you must defeat it to win. Progress stays capped at levelGoal meanwhile.
    let boss = null; // holds boss entity on level 4
    
    function bulletsPerReloadForLevel(lvl) {
      return (lvl === 2) ? 15 : bulletsPerReload; // L2 gets 15, others keep default 10
    }
    function checkAnswer() {
      const val = mathAnswerEl.value.trim();
      if (val === '') return;
      const answer = Number(val);
      if (Number.isNaN(answer)) return;

      if (answer === currentMathProblem.answer) {
        questionIndex[level]++;
        bullets = bulletsPerReloadForLevel(level);
        if (level !== 4 || !boss) { // while boss alive, don't add progress past goal
          correctThisLevel = Math.min(levelGoal, correctThisLevel + 1);
        }
        updateUI();

        // Handle level advance or boss spawn
        let triggeredShop = false;
        if (correctThisLevel >= levelGoal) {
          if (level < maxLevel) {
            coins += coinsPerLevel;
            const nextLevel = level + 1;
            level = nextLevel;
            correctThisLevel = 0;
            pendingLevel = nextLevel;
            levelGoal = levelQuestions[nextLevel].length;
            triggeredShop = true;
          } else {
            // Level 4: gate by boss. If not spawned, spawn now.
            if (!boss) spawnBoss();
          }
        }

        mathPrompt.style.display = 'none';
        isReloading = false;

        if (triggeredShop) {
          updateUI();
          openShop();
          return;
        }
      } else {
        mathAnswerEl.style.borderColor = '#ff0000';
        setTimeout(() => {
          mathAnswerEl.style.borderColor = '#00ff00';
          mathAnswerEl.value = '';
          mathAnswerEl.focus();
        }, 350);
      }
    }

    function gameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverEl.style.display = 'block';
    }
    function winGame() {
      gameRunning = false;
      finalWinScoreEl.textContent = score;
      youWinEl.style.display = 'block';
    }

    function restartGame() {
      score = 0;
      bullets = bulletsPerReload;
      coins = 0;
      health = 100;
      lives = 3;
      targets = [];
      explosions = [];
      hearts = [];
      coinChests3D = [];
      coinChests2D = [];
      heartSpawnActive = false;
      heartSpawnTimer = 0;
      enemies2D = [];
      projectiles = [];
      boss = null;
      gameRunning = true;
      isReloading = false;
      isPaused = false;
      level = 1;
      correctThisLevel = 0;
      currentWeapon = 'blaster';
      ownedWeapons.clear();
      ownedWeapons.add('blaster');
      nukeCount = 0;
      pendingLevel = null;
      for (let k in questionIndex) questionIndex[k] = 0;
      lastTime = 0;
      gameOverEl.style.display = 'none';
      youWinEl.style.display = 'none';
      mathPrompt.style.display = 'none';
      pauseScreen.style.display = 'none';
      shopScreen.style.display = 'none';
      syncSpeedFromSlider();
      configureLevel(1);
      updateUI();
      showBanner(`Level ${level}: ${levelOps[level].name}`);
    }

    function togglePause() {
      if (!isPaused && (!gameRunning || startScreen.style.display !== 'none')) return;
      isPaused = !isPaused;
      gameRunning = !isPaused;
      if (isPaused) {
        pauseScreen.style.display = 'block';
        player.moveLeft = false; player.moveRight = false;
      } else {
        pauseScreen.style.display = 'none';
      }
    }

    // ===== ENTITIES — Level 1 (3D skulls, original Target) =====
    class Target {
      constructor(params) {
        this.x = (Math.random() - 0.5) * 200;
        this.y = (Math.random() - 0.5) * 100;
        this.z = params.zStart;
        this.baseSpeed = randRange(params.speedRange[0], params.speedRange[1]); // per-frame at 60fps baseline
        this.size = 20;
        this.hit = false;
      }
      update(dt) {
        if (!this.hit) {
          this.z -= this.baseSpeed * speedMultiplier * dt;
          if (this.z <= 1) { health -= 10; updateUI(); return false; }
        }
        return true;
      }
      getScreenCoords() {
        const scale = 200 / Math.max(1, this.z);
        const screenX = vanishingPoint.x + (this.x * scale);
        const screenY = vanishingPoint.y + (this.y * scale);
        const screenSize = this.size * scale;
        return { x: screenX, y: screenY, size: screenSize };
      }
      draw() {
        const c = this.getScreenCoords();
        ctx.save();
        const size = c.size;
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = size * 0.5;

        // Skull cranium
        ctx.fillStyle = '#f0f0f0';
        ctx.beginPath(); ctx.arc(c.x, c.y - size * 0.2, size * 0.8, 0, Math.PI * 2); ctx.fill();
        // Jaw
        ctx.beginPath(); ctx.ellipse(c.x, c.y + size * 0.3, size * 0.6, size * 0.5, 0, 0, Math.PI * 2); ctx.fill();
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.ellipse(c.x - size * 0.25, c.y - size * 0.2, size * 0.2, size * 0.25, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(c.x + size * 0.25, c.y - size * 0.2, size * 0.2, size * 0.25, 0, 0, Math.PI * 2); ctx.fill();
        // Eye glow
        ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(c.x - size * 0.25, c.y - size * 0.2, size * 0.05, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(c.x + size * 0.25, c.y - size * 0.2, size * 0.05, 0, Math.PI * 2); ctx.fill();
        // Nose
        ctx.fillStyle = '#000'; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.moveTo(c.x, c.y); ctx.lineTo(c.x - size * 0.1, c.y + size * 0.15); ctx.lineTo(c.x + size * 0.1, c.y + size * 0.15);
        ctx.closePath(); ctx.fill();
        // Teeth
        ctx.fillStyle = '#f0f0f0'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        const teethCount = 6; const teethWidth = (size * 0.6) / teethCount;
        for (let i = 0; i < teethCount; i++) {
          const x = c.x - size * 0.3 + i * teethWidth + teethWidth / 2;
          ctx.fillRect(x - teethWidth * 0.3, c.y + size * 0.35, teethWidth * 0.6, size * 0.15);
          ctx.strokeRect(x - teethWidth * 0.3, c.y + size * 0.35, teethWidth * 0.6, size * 0.15);
        }
        // Crack
        ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(c.x - size * 0.1, c.y - size * 0.6); ctx.lineTo(c.x - size * 0.05, c.y - size * 0.3); ctx.stroke();
        ctx.restore();
      }
      checkHit(x, y) {
        const c = this.getScreenCoords();
        const dist = Math.hypot(x - c.x, y - c.y);
        return dist < c.size;
      }
    }

    class Explosion {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.particles = [];
        for (let i = 0; i < 15; i++) {
          this.particles.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 1 });
        }
      }
      update(dt) {
        this.particles = this.particles.filter(p => {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 0.2 * dt;    // gravity-ish
          p.life -= 0.03 * dt; // fade rate
          return p.life > 0;
        });
        return this.particles.length > 0;
      }
      draw() {
        this.particles.forEach(p => {
          ctx.fillStyle = `rgba(0, 255, ${Math.floor(p.life * 100)}, ${p.life})`;
          ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 10;
          ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        });
        ctx.shadowBlur = 0;
      }
    }

    // ===== Backgrounds (Level 1 canyon as-is) =====
    const tombstones = [];
    function initDecor() {
      tombstones.length = 0;
      for (let i = 0; i < 60; i++) {
        const x = Math.random() * canvas.width;
        const y = vanishingPoint.y + Math.random() * (canvas.height - vanishingPoint.y);
        const size = 2 + (y - vanishingPoint.y) / (canvas.height - vanishingPoint.y) * 4;
        tombstones.push({ x, y, size });
      }
    }
    function drawCanyon() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#000000');
      gradient.addColorStop(0.5, '#001a00');
      gradient.addColorStop(1, '#003300');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const fogGradient = ctx.createRadialGradient(vanishingPoint.x, vanishingPoint.y, 0, vanishingPoint.x, vanishingPoint.y, canvas.width);
      fogGradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
      fogGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = fogGradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = '#004400'; ctx.lineWidth = 2; ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 5;

      for (let i = 0; i <= 10; i++) {
        const lx = (i / 10) * vanishingPoint.x;
        ctx.beginPath(); ctx.moveTo(lx, canvas.height); ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(lx, 0);             ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();

        const rx = vanishingPoint.x + (i / 10) * (canvas.width - vanishingPoint.x);
        ctx.beginPath(); ctx.moveTo(rx, canvas.height); ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rx, 0);             ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();
      }
      for (let i = 1; i <= 8; i++) {
        const f = i / 8;
        const left = vanishingPoint.x - (vanishingPoint.x * f);
        const right = vanishingPoint.x + ((canvas.width - vanishingPoint.x) * f);
        const top = vanishingPoint.y - (vanishingPoint.y * f);
        const bottom = vanishingPoint.y + ((canvas.height - vanishingPoint.y) * f);
        ctx.beginPath(); ctx.moveTo(left, top); ctx.lineTo(right, top); ctx.lineTo(right, bottom); ctx.lineTo(left, bottom);
        ctx.closePath(); ctx.stroke();
      }
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#002200';
      tombstones.forEach(t => {
        ctx.fillRect(t.x - t.size / 2, t.y - t.size, t.size, t.size);
        ctx.beginPath(); ctx.arc(t.x, t.y - t.size, t.size / 2, Math.PI, 0); ctx.fill();
      });
    }

    // ===== NEW: 2D mode (enemies, player, bullets) =====
    let enemies2D = [];
    let projectiles = [];

    const player = {
      x: canvas.width * 0.5,
      y: canvas.height - 60, // bottom by default (L2, L4)
      w: 26, h: 26,
      speed: 480, // px/s
      moveLeft: false, moveRight: false,
      topMode: false,       // L3 puts the ship at the top
      bulletDir: -1,        // up on L2/L4, down on L3
    };
    function clampPlayer() {
      player.x = clamp(player.x, 30, canvas.width - 30);
      player.y = player.topMode ? 60 : canvas.height - 60;
    }
    function drawShip() {
      const x = player.x, y = player.y, s = 18;
      ctx.save();

      if (currentMode === Modes.JELLIES) {
        // Water background under the ship
        const waterTop = y + s * 0.9;
        ctx.fillStyle = 'rgba(0,80,160,0.4)';
        ctx.fillRect(0, waterTop, canvas.width, canvas.height - waterTop);
        ctx.strokeStyle = '#00aaff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, waterTop);
        ctx.lineTo(canvas.width, waterTop);
        ctx.stroke();

        // Simple boat hull
        ctx.fillStyle = '#b5651d';
        ctx.beginPath();
        ctx.moveTo(x - s, y);
        ctx.lineTo(x + s, y);
        ctx.lineTo(x + s * 0.6, y + s * 0.8);
        ctx.lineTo(x - s * 0.6, y + s * 0.8);
        ctx.closePath();
        ctx.fill();

        // Cabin / mast
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(x, y - s);
        ctx.lineTo(x, y);
        ctx.lineTo(x + s * 0.6, y);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.shadowColor = currentMode === Modes.BATS ? '#ff7a00' : '#7afcff';
        ctx.shadowBlur = 15;
        ctx.fillStyle = currentMode === Modes.BATS ? '#ffa64d' : '#aef';
        ctx.beginPath();
        ctx.moveTo(x, y - s);
        ctx.lineTo(x - s * 0.7, y + s * 0.9);
        ctx.lineTo(x + s * 0.7, y + s * 0.9);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.restore();
    }

    class Bullet {
      constructor({ x, y, dir, speed, r, damage, vx }) {
        this.x = x;
        this.y = y;
        this.dir = dir; // -1 up, +1 down
        this.speed = speed ?? (currentMode === Modes.JELLIES ? 200 : 620);
        this.r = r ?? (currentMode === Modes.JELLIES ? 6 : 3.5);
        this.damage = damage ?? 1;
        this.vx = vx ?? 0;
      }
      update(deltaSec) {
        this.x += this.vx * deltaSec;
        this.y += this.dir * this.speed * deltaSec; // bullets ignore slow-mo
        return (this.y > -40 && this.y < canvas.height + 40 && this.x > -40 && this.x < canvas.width + 40);
      }
      draw() {
        if (currentMode === Modes.JELLIES) {
          ctx.fillStyle = '#ddd';
          ctx.fillRect(this.x - 3, this.y - 8, 6, 16);
          ctx.fillStyle = '#f00';
          ctx.fillRect(this.x - 5, this.y + 8, 10, 4);
        } else {
          ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        }
      }
    }

    class Heart {
      constructor() {
        this.x = randInt(30, canvas.width - 30);
        this.y = -40;
        this.vy = 60;
        this.r = 16;
      }
      update(deltaSec) {
        this.y += this.vy * speedMultiplier * deltaSec;
        return this.y < canvas.height + 40;
      }
      draw() {
        ctx.save();
        ctx.fillStyle = '#ff4d4d';
        ctx.shadowColor = '#ff4d4d'; ctx.shadowBlur = 20;
        const x = this.x, y = this.y, r = this.r;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + r, y - r, x + r*2, y + r, x, y + r*2);
        ctx.bezierCurveTo(x - r*2, y + r, x - r, y - r, x, y);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
      }
      hitTest(px, py, pr=0) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class CoinChest3D {
      constructor(params) {
        this.z = params.zStart;
        this.x = (Math.random() - 0.5) * 180;
        this.y = (Math.random() - 0.5) * 90;
        this.baseSpeed = randRange(params.speedRange[0] * 0.65, params.speedRange[1] * 0.85);
        this.size = 24;
      }
      update(dt) {
        this.z -= this.baseSpeed * speedMultiplier * dt;
        return this.z > 1.2;
      }
      getScreenCoords() {
        const scale = 200 / Math.max(1.2, this.z);
        const screenX = vanishingPoint.x + (this.x * scale);
        const screenY = vanishingPoint.y + (this.y * scale);
        const screenSize = this.size * scale;
        return { x: screenX, y: screenY, size: screenSize };
      }
      draw() {
        const c = this.getScreenCoords();
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.shadowColor = '#ffd966'; ctx.shadowBlur = c.size * 0.5;
        ctx.fillStyle = '#a6692a';
        const boxW = c.size * 1.4;
        const boxH = c.size * 0.9;
        ctx.fillRect(-boxW/2, -boxH/2, boxW, boxH);
        ctx.fillStyle = '#d48836';
        ctx.fillRect(-boxW/2, -boxH*0.2, boxW, boxH*0.4);
        ctx.fillStyle = '#ffd966';
        ctx.fillRect(-4, -boxH/2, 8, boxH);
        ctx.strokeStyle = '#ffd966'; ctx.lineWidth = 2;
        ctx.strokeRect(-boxW/2, -boxH/2, boxW, boxH);
        ctx.restore();
      }
      checkHit(x, y) {
        const c = this.getScreenCoords();
        const dx = Math.abs(x - c.x);
        const dy = Math.abs(y - c.y);
        return dx < c.size * 0.8 && dy < c.size * 0.6;
      }
    }

    class CoinChest2D {
      constructor(mode) {
        this.mode = mode;
        this.x = randInt(40, canvas.width - 40);
        this.radius = 20;
        if (mode === Modes.JELLIES) {
          this.y = canvas.height + 40;
          this.vy = -randRange(70, 110);
        } else {
          this.y = -40;
          this.vy = randRange(70, 110);
        }
      }
      update(deltaSec) {
        this.y += this.vy * speedMultiplier * deltaSec;
        if (this.mode === Modes.JELLIES) {
          return this.y > -60;
        }
        return this.y < canvas.height + 60;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowColor = '#ffd966'; ctx.shadowBlur = 18;
        ctx.fillStyle = '#a6692a';
        ctx.fillRect(-22, -16, 44, 28);
        ctx.fillStyle = '#d48836';
        ctx.fillRect(-22, -4, 44, 12);
        ctx.fillStyle = '#ffd966';
        ctx.fillRect(-4, -16, 8, 28);
        ctx.strokeStyle = '#ffd966'; ctx.lineWidth = 2;
        ctx.strokeRect(-22, -16, 44, 28);
        ctx.restore();
      }
      hitTest(px, py, pr=0) {
        return Math.hypot(this.x - px, this.y - py) < (this.radius + pr);
      }
    }

    // ---- Enemy types for 2D modes ----
    class Bat {
      constructor() {
        this.x0 = randInt(30, canvas.width - 30);
        this.y = -40; // top
        this.amp = randRange(level2Params.ampRange[0], level2Params.ampRange[1]);
        this.freq = randRange(level2Params.freqRange[0], level2Params.freqRange[1]);
        this.vy = randRange(level2Params.vyRange[0], level2Params.vyRange[1]);
        this.hp = level2Params.hp;
        this.t = Math.random()*10;
        this.r = 18;
      }
      update(deltaSec) {
        this.t += deltaSec;
        this.x = this.x0 + Math.sin(this.t * Math.PI * 2 * this.freq) * this.amp;
        this.y += this.vy * speedMultiplier * deltaSec;
        // Touch bottom line (player row) => damage
        if (this.y >= canvas.height - 24) { health -= level2Params.touchDamage; updateUI(); return false; }
        return true;
      }
      draw() {
        // orange-glow bat
        ctx.save();
        ctx.shadowColor = '#ff7a00'; ctx.shadowBlur = 22;
        ctx.fillStyle = '#ff7a00';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 4);
        ctx.quadraticCurveTo(this.x - 20, this.y + 10, this.x - 10, this.y + 16);
        ctx.lineTo(this.x, this.y + 4);
        ctx.lineTo(this.x + 10, this.y + 16);
        ctx.quadraticCurveTo(this.x + 20, this.y + 10, this.x, this.y - 4);
        ctx.fill();
        ctx.shadowBlur = 0;
        // eyes
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(this.x - 4, this.y + 4, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(this.x + 4, this.y + 4, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class Jelly {
      constructor() {
        this.x = randInt(30, canvas.width - 30);
        this.y = canvas.height + 40; // from bottom, going up
        this.vy = -randRange(level3Params.vyRange[0], level3Params.vyRange[1]);
        this.vx = randRange(level3Params.driftRange[0], level3Params.driftRange[1]);
        this.hp = level3Params.hp;
        this.r = 20;
        this.pulse = Math.random()*Math.PI*2;
      }
      update(deltaSec) {
        this.pulse += deltaSec*2;
        this.x += this.vx * speedMultiplier * deltaSec;
        this.y += this.vy * speedMultiplier * deltaSec;
        if (this.y <= 24) { health -= level3Params.touchDamage; updateUI(); return false; }
        if (this.x < -30 || this.x > canvas.width + 30) return false;
        return true;
      }
      draw() {
        ctx.save();
        ctx.shadowColor = '#66ffd4'; ctx.shadowBlur = 18;
        ctx.fillStyle = '#66ffd4';
        const r = this.r * (0.9 + 0.1*Math.sin(this.pulse));
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, r*0.9, r*0.7, 0, 0, Math.PI*2); ctx.fill();
        // tendrils
        ctx.strokeStyle = '#44ddb8'; ctx.lineWidth = 2;
        for (let i=-2;i<=2;i++){
          ctx.beginPath();
          ctx.moveTo(this.x + i*4, this.y + r*0.3);
          ctx.quadraticCurveTo(this.x + i*6, this.y + r*0.6, this.x + i*3, this.y + r);
          ctx.stroke();
        }
        ctx.restore();
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class Alien {
      constructor() {
        this.x0 = randInt(30, canvas.width - 30);
        this.y = -40;
        this.amp = randRange(level4Params.ampRange[0], level4Params.ampRange[1]);
        this.freq = randRange(level4Params.freqRange[0], level4Params.freqRange[1]);
        this.vy = randRange(level4Params.vyRange[0], level4Params.vyRange[1]);
        this.hp = level4Params.hp;
        this.t = Math.random()*10;
        this.r = 18;
      }
      update(deltaSec) {
        this.t += deltaSec;
        this.x = this.x0 + Math.cos(this.t * Math.PI * 2 * this.freq) * this.amp;
        this.y += this.vy * speedMultiplier * deltaSec;
        if (this.y >= canvas.height - 24) { health -= level4Params.touchDamage; updateUI(); return false; }
        return true;
      }
      draw() {
        ctx.save();
        ctx.shadowColor = '#7afcff'; ctx.shadowBlur = 22;
        ctx.fillStyle = '#9fe6ff';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 18, 12, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#003f5c';
        ctx.beginPath(); ctx.ellipse(this.x, this.y, 8, 6, 0, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class Boss {
      constructor() {
        this.x = canvas.width/2; this.y = 120;
        this.vx = level4Params.bossSpeed; this.dir = 1;
        this.hp = level4Params.bossHP;
        this.r = 42;
      }
      update(deltaSec) {
        this.x += this.dir * this.vx * speedMultiplier * deltaSec;
        if (this.x < 60) { this.x = 60; this.dir = 1; }
        if (this.x > canvas.width - 60) { this.x = canvas.width - 60; this.dir = -1; }
        return this.hp > 0;
      }
      draw() {
        ctx.save();
        ctx.shadowColor = '#ff3'; ctx.shadowBlur = 28;
        ctx.fillStyle = '#ffd54d';
        ctx.beginPath(); ctx.ellipse(this.x, this.y, 70, 40, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#ff7733';
        ctx.beginPath(); ctx.arc(this.x-22, this.y-6, 8, 0, Math.PI*2); ctx.arc(this.x+22, this.y-6, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#222';
        ctx.fillRect(this.x-18, this.y+10, 36, 4);
        ctx.restore();

        // Boss health bar
        const w = 240, h = 8, x = canvas.width/2 - w/2, y = 24;
        ctx.strokeStyle = '#ff3'; ctx.strokeRect(x, y, w, h);
        const frac = clamp(this.hp / level4Params.bossHP, 0, 1);
        ctx.fillStyle = '#ff3'; ctx.fillRect(x, y, w*frac, h);
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    // ===== NEW: 2D backgrounds =====
    function drawBatCaveBG() {
      // Dark center with orange border glow (like your screenshot)
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.width*0.2, canvas.width/2, canvas.height/2, canvas.width*0.8);
      g.addColorStop(0,'rgba(0,0,0,0.6)'); g.addColorStop(1,'rgba(0,0,0,1)'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      // Frame glow
      ctx.shadowColor = '#ff7a00'; ctx.shadowBlur = 35; ctx.strokeStyle = '#ff7a00'; ctx.lineWidth = 6;
      ctx.strokeRect(20,20,canvas.width-40,canvas.height-40);
      ctx.shadowBlur = 0;
    }
    function drawSwampBG() {
      const g = ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#001015'); g.addColorStop(0.5,'#002b2b'); g.addColorStop(1,'#003a2a');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
      // Murky bubbles
      for (let i=0;i<12;i++){
        const x = (i/11)*canvas.width + Math.sin(i)*40, y = canvas.height*0.6 + (i%2)*40;
        ctx.fillStyle = 'rgba(80,180,140,0.08)'; ctx.beginPath(); ctx.arc(x,y, randRange(14,38), 0, Math.PI*2); ctx.fill();
      }
    }

    // Starfield for Level 4
    let stars = [];
    function initStars() {
      const count = Math.floor((canvas.width*canvas.height)/25000);
      stars = Array.from({length: count}, () => ({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        z: Math.random()*2 + 0.5
      }));
    }
    function drawSpaceBG(deltaSec) {
      ctx.fillStyle = '#000015'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#9fe6ff';
      stars.forEach(s => {
        s.y += 40*s.z*speedMultiplier*deltaSec;
        if (s.y > canvas.height) { s.y = 0; s.x = Math.random()*canvas.width; s.z = Math.random()*2 + 0.5; }
        ctx.fillRect(s.x, s.y, s.z, s.z);
      });
      // subtle nebula
      const g = ctx.createRadialGradient(canvas.width*0.7, canvas.height*0.3, 10, canvas.width*0.7, canvas.height*0.3, canvas.width*0.6);
      g.addColorStop(0,'rgba(120,200,255,0.15)'); g.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // ===== Game loop =====
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaMs = timestamp - lastTime;
      const dt = deltaMs / (1000 / 60);   // normalized (60fps)
      const deltaSec = deltaMs / 1000;    // real seconds
      lastTime = timestamp;

      // Background per-level
      if (currentMode === Modes.CANYON) drawCanyon();
      else if (currentMode === Modes.BATS) drawBatCaveBG();
      else if (currentMode === Modes.JELLIES) drawSwampBG();
      else if (currentMode === Modes.ALIENS) drawSpaceBG(deltaSec);

      if (gameRunning) {
        if (currentMode === Modes.CANYON) {
          // Stable spawns (Poisson)
          const lp = level1Params;
          const reloadFactor = isReloading ? 0.35 : 1.0;
          const lambda = lp.spawnPerSec * reloadFactor * speedMultiplier;
          const spawnProb = 1 - Math.exp(-lambda * deltaSec);
          if (Math.random() < spawnProb) targets.push(new Target(lp));

          const chestLambda = coinChestSpawnRates.canyon * reloadFactor * speedMultiplier;
          const chestProb = 1 - Math.exp(-chestLambda * deltaSec);
          if (Math.random() < chestProb) coinChests3D.push(new CoinChest3D(lp));

          // Draw far-to-near (bigger z first)
          const combined = [
            ...targets.map(entity => ({ entity, type: 'target' })),
            ...coinChests3D.map(entity => ({ entity, type: 'chest' }))
          ];
          combined.sort((a, b) => b.entity.z - a.entity.z);
          const newTargets = [];
          const newChests = [];
          combined.forEach(item => {
            const alive = item.entity.update(dt);
            if (!alive) return;
            item.entity.draw();
            if (item.type === 'target') newTargets.push(item.entity);
            else newChests.push(item.entity);
          });
          targets = newTargets;
          coinChests3D = newChests;
          explosions = explosions.filter(ex => { const alive = ex.update(dt); if (alive) ex.draw(); return alive; });

        } else {
          // ==== NEW: 2D mode update ====
          // Spawn by level
          let spawnPerSec = (currentMode===Modes.BATS?level2Params.spawnPerSec:
                             currentMode===Modes.JELLIES?level3Params.spawnPerSec:level4Params.spawnPerSec);
          const reloadFactor = isReloading ? 0.35 : 1.0;
          const lambda = spawnPerSec * reloadFactor * speedMultiplier;
          const spawnProb = 1 - Math.exp(-lambda * deltaSec);

          const chestLambda = coinChestSpawnRates.twoD * reloadFactor * speedMultiplier;
          const chestProb = 1 - Math.exp(-chestLambda * deltaSec);
          if (Math.random() < chestProb) coinChests2D.push(new CoinChest2D(currentMode));

          if (!boss) { // while boss alive we stop adding more aliens
            if (Math.random() < spawnProb) {
              if (currentMode === Modes.BATS) enemies2D.push(new Bat());
              else if (currentMode === Modes.JELLIES) enemies2D.push(new Jelly());
              else if (currentMode === Modes.ALIENS) enemies2D.push(new Alien());
            }
          }

          coinChests2D = coinChests2D.filter(ch => {
            if (ch.mode !== currentMode) return false;
            const alive = ch.update(deltaSec);
            if (!alive) return false;
            ch.draw();
            for (let i=0;i<projectiles.length;i++) {
              const b = projectiles[i];
              if (ch.hitTest(b.x, b.y, b.r)) {
                projectiles.splice(i,1);
                grantChestCoins(ch.x, ch.y);
                return false;
              }
            }
            return true;
          });

          // Player motion (keyboard or mouse X) — ship speed is not slowed
          const move = (player.moveRight ? 1 : 0) - (player.moveLeft ? 1 : 0);
          player.x += move * player.speed * deltaSec;
          clampPlayer();

          // Update bullets
          projectiles = projectiles.filter(b => { const alive = b.update(deltaSec); if (alive) b.draw(); return alive; });

          // Collisions: bullets vs enemies
          enemies2D = enemies2D.filter(en => {
            // move enemy
            const alive = en.update(deltaSec);
            if (!alive) return false;

            // draw enemy
            en.draw();

            // collide with player row (bonus: grazing not required since damage handled on update)

            // bullets hit
            for (let i=0;i<projectiles.length;i++){
              const b = projectiles[i];
              if (en.hitTest(b.x, b.y, b.r)) {
                en.hp -= b.damage ?? 1; score += 25; // per-hit score
                projectiles.splice(i,1);
                explosions.push(new Explosion(en.x || en.x0 || b.x, en.y || b.y));
                break;
              }
            }
            return en.hp > 0;
          });

          // Boss update/draw/hit
          if (boss) {
            if (!boss.update(deltaSec)) { boss = null; winGame(); }
            else {
              boss.draw();
              // bullets vs boss
              for (let i=0;i<projectiles.length;i++){
                const b = projectiles[i];
                if (boss.hitTest(b.x, b.y, b.r)) {
                  boss.hp -= b.damage ?? 1; score += 40;
                  projectiles.splice(i,1);
                  explosions.push(new Explosion(boss.x, boss.y));
                  break;
                }
              }
            }
          }

          // Draw explosions
          explosions = explosions.filter(ex => { const alive = ex.update(dt); if (alive) ex.draw(); return alive; });
        }

        if (!heartSpawnActive && health < 40) { heartSpawnActive = true; heartSpawnTimer = 0; }
        if (heartSpawnActive) {
          heartSpawnTimer -= deltaSec;
          if (heartSpawnTimer <= 0) {
            hearts.push(new Heart());
            heartSpawnTimer = heartSpawnInterval;
          }
          if (health >= 75) heartSpawnActive = false;
        }

        hearts = hearts.filter(h => {
          const alive = h.update(deltaSec);
          if (!alive) return false;
          h.draw();
          if (currentMode !== Modes.CANYON) {
            for (let i=0;i<projectiles.length;i++) {
              const b = projectiles[i];
              if (h.hitTest(b.x, b.y, b.r)) {
                projectiles.splice(i,1);
                health = Math.min(100, health + 10);
                updateUI();
                return false;
              }
            }
          }
          return true;
        });
      }

      // Reticle or ship
      if (currentMode === Modes.CANYON) drawCrosshair();
      else drawShip();

      requestAnimationFrame(gameLoop);
    }

    function drawCrosshair() {
      ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 5;
      ctx.beginPath(); ctx.arc(mouseX, mouseY, 15, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(mouseX - 20, mouseY); ctx.lineTo(mouseX - 10, mouseY);
      ctx.moveTo(mouseX + 10, mouseY); ctx.lineTo(mouseX + 20, mouseY);
      ctx.moveTo(mouseX, mouseY - 20); ctx.lineTo(mouseX, mouseY - 10);
      ctx.moveTo(mouseX, mouseY + 10); ctx.lineTo(mouseX, mouseY + 20);
      ctx.stroke(); ctx.shadowBlur = 0;
    }

    // ===== Events =====
    function fireHitscanShots(shots) {
      if (!Array.isArray(shots)) return;
      shots.forEach(shot => {
        let remaining = shot && shot.pierce ? shot.pierce : 1;
        if (!shot) return;

        if (hearts.length) {
          for (let i = hearts.length - 1; i >= 0; i--) {
            if (hearts[i].hitTest(shot.x, shot.y)) {
              hearts.splice(i, 1);
              health = Math.min(100, health + 10);
              updateUI();
              remaining = 0;
              break;
            }
          }
        }

        if (remaining > 0 && coinChests3D.length) {
          for (let i = coinChests3D.length - 1; i >= 0; i--) {
            const chest = coinChests3D[i];
            if (chest.checkHit(shot.x, shot.y)) {
              const coords = chest.getScreenCoords();
              grantChestCoins(coords.x, coords.y);
              coinChests3D.splice(i, 1);
              remaining = 0;
              break;
            }
          }
        }

        while (remaining > 0) {
          const sorted = [...targets].sort((a, b) => a.z - b.z);
          let hit = false;
          for (let t of sorted) {
            if (t.checkHit(shot.x, shot.y)) {
              score += Math.floor(100 / t.z * 10);
              explosions.push(new Explosion(shot.x, shot.y));
              const idx = targets.indexOf(t);
              if (idx !== -1) targets.splice(idx, 1);
              updateUI();
              remaining--;
              hit = true;
              break;
            }
          }
          if (!hit) break;
        }
      });
    }

    function activateNuke() {
      if (!gameRunning || nukeCount <= 0) return;
      nukeCount--;
      const blastCount = 12;
      for (let i = 0; i < blastCount; i++) {
        const exX = Math.random() * canvas.width;
        const exY = Math.random() * canvas.height;
        explosions.push(new Explosion(exX, exY));
      }
      targets = [];
      enemies2D = [];
      projectiles = [];
      hearts = [];
      coinChests3D = [];
      coinChests2D = [];
      if (boss) { boss.hp = 0; }
      updateUI();
    }

    function purchaseItem(item) {
      if (!item) return;
      if (item.type === 'nuke') {
        if (coins < item.cost) return;
        coins -= item.cost;
        nukeCount++;
        updateUI();
        renderShop();
        return;
      }

      if (ownedWeapons.has(item.id) || coins < item.cost) return;
      coins -= item.cost;
      ownedWeapons.add(item.id);
      currentWeapon = item.id;
      updateUI();
      renderShop();
    }

    function equipWeapon(id) {
      if (!ownedWeapons.has(id)) return;
      currentWeapon = id;
      updateUI();
      renderShop();
    }

    function renderShop() {
      shopCoinsEl.textContent = `Coins: ${coins}`;
      shopItemsEl.innerHTML = '';
      shopItems.forEach(item => {
        const wrapper = document.createElement('div');
        wrapper.className = 'item';
        const header = document.createElement('header');
        const nameSpan = document.createElement('span');
        nameSpan.textContent = item.name;
        const costSpan = document.createElement('span');
        costSpan.textContent = `${item.cost} coins`;
        header.appendChild(nameSpan);
        header.appendChild(costSpan);
        const desc = document.createElement('p');
        desc.textContent = item.description;
        const btn = document.createElement('button');

        if (item.type === 'nuke') {
          btn.textContent = 'Buy Nuke';
          btn.disabled = coins < item.cost;
          btn.addEventListener('click', () => purchaseItem(item));
        } else {
          const owned = ownedWeapons.has(item.id);
          if (!owned) {
            btn.textContent = `Buy for ${item.cost}`;
            btn.disabled = coins < item.cost;
            btn.addEventListener('click', () => purchaseItem(item));
          } else if (currentWeapon === item.id) {
            btn.textContent = 'Equipped';
            btn.disabled = true;
          } else {
            btn.textContent = 'Equip';
            btn.disabled = false;
            btn.addEventListener('click', () => equipWeapon(item.id));
          }
        }

        wrapper.appendChild(header);
        wrapper.appendChild(desc);
        wrapper.appendChild(btn);
        shopItemsEl.appendChild(wrapper);
      });
    }

    function openShop() {
      gameRunning = false;
      isPaused = false;
      pauseScreen.style.display = 'none';
      mathPrompt.style.display = 'none';
      isReloading = false;
      renderShop();
      shopScreen.style.display = 'block';
    }

    function closeShop() {
      shopScreen.style.display = 'none';
      if (pendingLevel) {
        configureLevel(pendingLevel);
        bullets = bulletsPerReloadForLevel(pendingLevel);
        correctThisLevel = 0;
        updateUI();
        showBanner(`Level ${pendingLevel}: ${levelOps[pendingLevel].name}`);
        pendingLevel = null;
      } else {
        updateUI();
      }
      gameRunning = true;
    }

    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX; mouseY = e.clientY;
      if (currentMode !== Modes.CANYON) { player.x = e.clientX; clampPlayer(); }
    });

    // Shooting
    function tryShoot() {
      if (!gameRunning || isReloading) return;
      const weapon = weaponCatalog[currentWeapon] || weaponCatalog.blaster;
      const bulletCost = weapon.bulletCost ?? 1;
      if (bullets < bulletCost) { showMathPrompt(); return; }
      bullets -= bulletCost;
      updateUI();

      if (currentMode === Modes.CANYON) {
        const shots = weapon.hitscanShots ? weapon.hitscanShots(mouseX, mouseY) : [{ x: mouseX, y: mouseY, pierce: 1 }];
        fireHitscanShots(shots);
      } else {
        const projs = weapon.projectiles ? weapon.projectiles(player) : [new Bullet({ x: player.x, y: player.y + (player.bulletDir > 0 ? 12 : -12), dir: player.bulletDir })];
        projs.forEach(p => projectiles.push(p));
      }

      if (bullets === 0) showMathPrompt();
    }

    canvas.addEventListener('click', tryShoot);

    mathAnswerEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') checkAnswer(); });
    answerBtn.addEventListener('click', checkAnswer);

    restartBtn1.addEventListener('click', () => { startScreen.style.display='none'; restartGame(); });
    restartBtn2.addEventListener('click', () => { startScreen.style.display='none'; restartGame(); });

    resumeBtn.addEventListener('click', togglePause);
    useNukeBtn.addEventListener('click', activateNuke);
    shopContinueBtn.addEventListener('click', closeShop);

    speedSlider.addEventListener('input', () => { syncSpeedFromSlider(); });

    window.addEventListener('resize', resize);

    // Keyboard controls for ship levels
    window.addEventListener('keydown', (e) => {
      if ((e.key === 'a' || e.key === 'A') && !e.repeat) {
        if (gameRunning && shopScreen.style.display === 'none') {
          e.preventDefault();
          openShop();
          player.moveLeft = false;
          player.moveRight = false;
          return;
        }
      }
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') player.moveLeft = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') player.moveRight = true;
      if (e.key === ' ' ) { e.preventDefault(); tryShoot(); }
      if ((e.key === 'p' || e.key === 'P') && !e.repeat) togglePause();
      if ((e.key === 'n' || e.key === 'N') && !e.repeat) activateNuke();
      if (!gameRunning && e.key === 'Enter' && startScreen.style.display !== 'none') startBtn.click();
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') player.moveLeft = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') player.moveRight = false;
    });

    // Start screen button
    startBtn.addEventListener('click', () => {
      startScreen.style.display = 'none';
      restartGame();
    });

    // ===== Level configuration =====
    function configureLevel(lvl) {
      // Switch interaction mode + background helpers
      if (lvl === 1) {
        currentMode = Modes.CANYON;
        document.body.classList.remove('ship-mode');
        canvas.style.cursor = 'crosshair';
      } else if (lvl === 2) {
        currentMode = Modes.BATS;
        document.body.classList.add('ship-mode');
        canvas.style.cursor = 'none';
        enemies2D = []; projectiles = []; explosions = []; boss = null;
        player.topMode = false; player.bulletDir = -1; clampPlayer();
      } else if (lvl === 3) {
        currentMode = Modes.JELLIES;
        document.body.classList.add('ship-mode');
        enemies2D = []; projectiles = []; explosions = []; boss = null;
        player.topMode = true; player.bulletDir = +1; clampPlayer();
      } else {
        currentMode = Modes.ALIENS;
        document.body.classList.add('ship-mode');
        enemies2D = []; projectiles = []; explosions = []; boss = null;
        player.topMode = false; player.bulletDir = -1; clampPlayer();
        initStars();
      }
      coinChests3D = [];
      coinChests2D = [];
      shuffleQuestionsForLevel(lvl);
      questionIndex[lvl] = 0;
      levelGoal = levelQuestions[lvl].length;
      levelEl.textContent = lvl;
      levelGoalEl.textContent = levelGoal;
      promptTitle.textContent = `RELOAD — Level ${lvl}: ${levelOps[lvl].name}`;
    }

    function spawnBoss() {
      boss = new Boss();
      showBanner('BOSS INCOMING!', 1600);
    }

    // ===== Start =====
    initDecor();
    initStars();
    syncSpeedFromSlider(); // ensure slider value applies
    updateUI();
    requestAnimationFrame(gameLoop);
    // Leave title showing; game begins when Start is clicked.
  </script>
</body>
</html>
