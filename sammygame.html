<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Canyon Math Shooter</title>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; cursor:crosshair; }
    #gameCanvas { display:block; background:#000; }

    /* === UI === */
    #ui {
      position:absolute; top:10px; left:10px; color:#00ff00; font-size:18px; text-shadow:0 0 10px #00ff00; font-weight:bold;
      background:rgba(0,0,0,0.5); border:2px solid #00ff00; padding:8px 10px; border-radius:6px; user-select:none; z-index:5;
    }
    #ui .row { margin:3px 0; }
    #ui label { font-weight:bold; margin-right:6px; }
    #speedSlider { vertical-align:middle; }
    #speedLabel { display:inline-block; min-width:42px; text-align:right; margin-left:6px; }

    /* === Start screen === */
    #startScreen {
      position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.98) 60%, rgba(0,0,0,1) 100%);
      color:#ff9; text-align:center; z-index:10;
      border: 3px solid #ff9; box-shadow:0 0 40px #ff9 inset, 0 0 60px #f80;
    }
    #startScreen h1 {
      font-size:64px; margin:0 0 8px 0; letter-spacing:2px; color:#fff3aa;
      text-shadow: 0 0 6px #ff9900, 0 0 18px #ff6600, 0 0 36px #ff3300;
    }
    #startScreen h2 { margin:0 0 24px 0; color:#ffa; font-weight:normal; }
    #startBtn {
      background:#ff9900; color:#000; border:none; padding:14px 26px; font-size:20px; font-weight:bold; cursor:pointer;
      box-shadow:0 0 20px #ff9900; border-radius:6px;
    }
    #startBtn:hover { background:#ffaa22; }

    /* === Math prompt === */
    #mathPrompt {
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.9); border:3px solid #00ff00; padding:20px; color:#00ff00; text-align:center; display:none;
      box-shadow:0 0 20px #00ff00; max-width:90%; z-index:6;
    }
    #mathPrompt h2 { margin:0 0 12px 0; font-size:22px; }
    #mathPrompt .q { font-size:36px; margin:16px 0 12px; }
    #mathPrompt input {
      background:#000; border:2px solid #00ff00; color:#00ff00; font-size:24px; padding:10px; width:120px; text-align:center;
      font-family:'Courier New', monospace;
    }
    #mathPrompt button {
      background:#00ff00; color:#000; border:none; padding:10px 20px; font-size:18px; margin-left:10px; cursor:pointer;
      font-family:'Courier New', monospace; font-weight:bold;
    }
    #mathPrompt button:hover { background:#00cc00; }

    /* === Overlays === */
    .overlay {
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      background:rgba(0,0,0,0.9); padding:28px; text-align:center; display:none; min-width:300px; z-index:7;
    }
    #gameOver { border:3px solid #ff0000; color:#ff0000; box-shadow:0 0 30px #ff0000; }
    #gameOver h2 { font-size:36px; margin:0 0 14px 0; }
    #gameOver button { background:#ff0000; color:#fff; border:none; padding:14px 26px; font-size:18px; cursor:pointer; font-weight:bold; }

    #youWin { border:3px solid #00ff66; color:#00ff66; box-shadow:0 0 30px #00ff66; }
    #youWin h2 { font-size:36px; margin:0 0 14px 0; }
    #youWin button { background:#00ff66; color:#000; border:none; padding:14px 26px; font-size:18px; cursor:pointer; font-weight:bold; }

    #pauseScreen { border:3px solid #00ffff; color:#00ffff; box-shadow:0 0 30px #00ffff; }
    #pauseScreen button { background:#00ffff; color:#000; border:none; padding:14px 26px; font-size:18px; cursor:pointer; font-weight:bold; }

    #levelBanner {
      position:absolute; top:50px; left:50%; transform:translateX(-50%);
      padding:10px 16px; border:2px solid #00ffcc; color:#00ffcc; background:rgba(0,0,0,0.75);
      font-weight:bold; display:none; text-shadow:0 0 10px #00ffcc; z-index:5;
    }

    #shopScreen {
      border:3px solid #ffaa33; color:#ffaa33; box-shadow:0 0 30px #ffaa33;
      display:flex; flex-direction:column; align-items:center; gap:8px;
    }
    #shopScreen h2 { margin-top:0; margin-bottom:12px; }
    #shopScreen #shopCoins { align-self:flex-start; }
    #shopScreen #shopItems { margin:14px 0; display:flex; flex-direction:column; gap:10px; width:100%; max-width:360px; }
    #shopScreen button { background:#ffaa33; color:#000; border:none; padding:12px 20px; font-size:16px; cursor:pointer; font-weight:bold; }
    #shopScreen > button { align-self:center; margin-top:8px; }
    #shopScreen button:disabled { background:#553300; color:#aa8855; cursor:not-allowed; }
    #shopScreen .item {
      border:2px solid #ffaa33; padding:10px; background:rgba(0,0,0,0.6); text-align:left; display:flex; flex-direction:column; gap:6px;
    }
    #shopScreen .item header { display:flex; justify-content:space-between; align-items:center; font-weight:bold; }
    #shopScreen .item p { margin:0; font-size:14px; color:#ffddaa; }

    #ui button.small {
      background:#ff3333; color:#fff; border:none; padding:4px 10px; font-size:14px; cursor:pointer; font-weight:bold;
    }
    #ui button.small:hover { background:#ff5555; }

    /* Subtle hide crosshair on 2D ship levels; we toggle a class on <body> */
    body.ship-mode { cursor:none; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- START SCREEN -->
  <div id="startScreen">
    <h1>Sammy's Game</h1>
    <h2>Math, Monsters, and Neon Mayhem</h2>
    <button id="startBtn">Start</button>
  </div>

  <!-- HUD -->
  <div id="ui">
    <div class="row">Score: <span id="score">0</span></div>
    <div class="row">Bullets: <span id="bullets">10</span></div>
    <div class="row">Coins: <span id="coins">0</span></div>
    <div class="row">Health: <span id="health">100</span></div>
    <div class="row">Lives: <span id="lives">❤️❤️❤️</span></div>
    <div class="row">Level: <span id="level">1</span>/4</div>
    <div class="row">Progress: <span id="progress">0</span>/<span id="levelGoal">0</span></div>
    <div class="row">Weapon: <span id="weaponName">Basic Blaster</span></div>
    <div class="row" id="nukeRow" style="display:none; gap:6px; align-items:center;">
      Nukes: <span id="nukeCount">0</span>
      <button id="useNukeBtn" class="small">Detonate</button>
    </div>
    <div class="row">
      <label for="speedSlider">Speed</label>
      <input type="range" id="speedSlider" min="0.25" max="2" step="0.05" value="0.50">
      <span id="speedLabel">0.5x</span>
    </div>
  </div>

  <!-- Math reload -->
  <div id="mathPrompt">
    <h2 id="promptTitle">RELOAD — Level 1: Addition</h2>
    <div id="mathQuestion" class="q"></div>
    <input type="number" id="mathAnswer" inputmode="numeric" autocomplete="off" />
    <button id="answerBtn">Fire!</button>
  </div>

  <!-- End screens -->
  <div id="gameOver" class="overlay">
    <h2>GAME OVER</h2>
    <div>Final Score: <span id="finalScore">0</span></div>
    <button id="restartBtn1">Play Again</button>
  </div>

  <div id="youWin" class="overlay">
    <h2>YOU BEAT THE GAME!</h2>
    <div>Final Score: <span id="finalWinScore">0</span></div>
    <button id="restartBtn2">Play Again</button>
  </div>

  <div id="pauseScreen" class="overlay">
    <h2>PAUSED</h2>
    <button id="resumeBtn">Resume</button>
  </div>

  <div id="levelBanner"></div>

  <div id="shopScreen" class="overlay">
    <h2>SUPPLY SHOP</h2>
    <div id="shopCoins">Coins: 0</div>
    <div id="shopItems"></div>
    <button id="shopContinueBtn">Continue</button>
  </div>

  <script>
    // ===== Canvas setup =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      vanishingPoint.x = canvas.width / 2;
      vanishingPoint.y = canvas.height / 2;
      initDecor();
      initStars(); // for level 4 background sizing
      clampPlayer();
    }
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const vanishingPoint = { x: canvas.width / 2, y: canvas.height / 2 };

    // ===== UI elements =====
    const scoreEl = document.getElementById('score');
    const bulletsEl = document.getElementById('bullets');
    const coinsEl = document.getElementById('coins');
    const healthEl = document.getElementById('health');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const progressEl = document.getElementById('progress');
    const levelGoalEl = document.getElementById('levelGoal');
    const weaponNameEl = document.getElementById('weaponName');
    const nukeRow = document.getElementById('nukeRow');
    const nukeCountEl = document.getElementById('nukeCount');
    const useNukeBtn = document.getElementById('useNukeBtn');
    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');
    const mathPrompt = document.getElementById('mathPrompt');
    const promptTitle = document.getElementById('promptTitle');
    const mathQuestionEl = document.getElementById('mathQuestion');
    const mathAnswerEl = document.getElementById('mathAnswer');
    const answerBtn = document.getElementById('answerBtn');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const youWinEl = document.getElementById('youWin');
    const finalWinScoreEl = document.getElementById('finalWinScore');
    const restartBtn1 = document.getElementById('restartBtn1');
    const restartBtn2 = document.getElementById('restartBtn2');
    const levelBanner = document.getElementById('levelBanner');
    const startScreen = document.getElementById('startScreen');
    const startBtn = document.getElementById('startBtn');
    const pauseScreen = document.getElementById('pauseScreen');
    const resumeBtn = document.getElementById('resumeBtn');
    const shopScreen = document.getElementById('shopScreen');
    const shopCoinsEl = document.getElementById('shopCoins');
    const shopItemsEl = document.getElementById('shopItems');
    const shopContinueBtn = document.getElementById('shopContinueBtn');

    // ===== Game state =====
    let score = 0;
    const bulletsPerReload = 10;
    let bullets = bulletsPerReload;
    let coins = 0;
    let health = 100;
    let lives = 3;
    const heartSpawnInterval = 5; // seconds between heart drops
    const coinsPerLevel = 10;
    const coinChestReward = { min: 5, max: 50 };
    const coinChestSpawnRates = { canyon: 0.12, twoD: 0.10 };

    let currentWeapon = 'blaster';
    const ownedWeapons = new Set(['blaster']);
    let nukeCount = 0;
    let pendingLevel = null;

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    let targets = [];      // Level-1 (3D) enemies
    let explosions = [];
    let hearts = [];
    let coinChests3D = [];
    let coinChests2D = [];
    let bossDefeatFx = [];
    let heartSpawnActive = false;
    let heartSpawnTimer = 0;
    let boomgunAim = null;
    let currentMathProblem = null;
    let isReloading = false;
    let gameRunning = false; // start on title screen
    let isPaused = false;

    // Driving level state
    let drivingLane = 1; // 0=left, 1=center, 2=right
    let roadScrollOffset = 0;
    let answerGates = [];
    let roadObstacles = [];
    let rivalCars = [];
    let gateSpawnTimer = 0;
    let drivingSpeed = 1.0; // multiplier for road speed
    let activeGateProblem = null; // current math problem for gates

    // Levels & progression
    let level = 1;
    const maxLevel = 4;
    let levelGoal = 0; // correct answers needed per level (set in configureLevel)
    let correctThisLevel = 0;
    let levelCleared = false;

    // Speed control (sync to slider at startup)
    let speedMultiplier = 1;

    // Frame timer for framerate-independent motion
    let lastTime = 0; // ms timestamp from rAF

    // ===== Helpers =====
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } // inclusive
    function randRange(min, max) { return Math.random() * (max - min) + min; }
    function clamp(val, a, b){ return Math.max(a, Math.min(b, val)); }

    // ===== Modes (how a level behaves) =====
    const Modes = { CANYON:'canyon', BATS:'bats', DRIVING:'driving', ALIENS:'aliens' };
    let currentMode = Modes.CANYON;

    // Per-level math label + symbol
    const levelOps = {
      1: { sym: '+', name: 'Addition' },
      2: { sym: '−', name: 'Subtraction' },
      3: { sym: '×', name: 'Neon Highway' },
      4: { sym: '×', name: 'Galactic Multiplication' }
    };

    const weaponCatalog = {
      blaster: {
        id: 'blaster',
        name: 'Basic Blaster',
        cost: 0,
        bulletCost: 1,
        description: 'Reliable single-shot laser.',
        hitscanShots: (x, y) => [{ x, y, pierce: 1 }],
        projectiles: (player) => [new Bullet({ x: player.x, y: player.y + (player.bulletDir > 0 ? 12 : -12), dir: player.bulletDir })]
      },
      rifle: {
        id: 'rifle',
        name: 'Plasma Rifle',
        cost: 20,
        bulletCost: 1,
        description: 'Piercing beam slices through two enemies.',
        hitscanShots: (x, y) => [{ x, y, pierce: 2 }],
        projectiles: (player) => [new Bullet({ x: player.x, y: player.y + (player.bulletDir > 0 ? 12 : -12), dir: player.bulletDir, speed: 820, r: 3, damage: 2 })]
      },
      shotgun: {
        id: 'shotgun',
        name: 'Scatter Shotgun',
        cost: 30,
        bulletCost: 3,
        description: 'Three bolt spread. Eats extra ammo but melts crowds.',
        hitscanShots: (x, y) => [
          { x: x - 25, y: y - 20, pierce: 1 },
          { x, y, pierce: 1 },
          { x: x + 25, y: y - 20, pierce: 1 }
        ],
        projectiles: (player) => {
          const baseY = player.y + (player.bulletDir > 0 ? 12 : -12);
          return [
            new Bullet({ x: player.x - 18, y: baseY, dir: player.bulletDir, vx: -180, damage: 1, speed: 560, r: 3.5 }),
            new Bullet({ x: player.x, y: baseY, dir: player.bulletDir, vx: 0, damage: 1, speed: 560, r: 3.5 }),
            new Bullet({ x: player.x + 18, y: baseY, dir: player.bulletDir, vx: 180, damage: 1, speed: 560, r: 3.5 })
          ];
        }
      },
      x2boomgun: {
        id: 'x2boomgun',
        name: 'X2 Boomgun',
        cost: 45,
        bulletCost: 2,
        description: 'Sniper laser fires twin super-charged bolts.',
        hitscanShots: (x, y) => [
          { x, y, pierce: 2 },
          { x, y, pierce: 2 }
        ],
        projectiles: (player) => {
          const baseY = player.y + (player.bulletDir > 0 ? 10 : -10);
          return [
            new Bullet({ x: player.x - 6, y: baseY, dir: player.bulletDir, speed: 980, r: 3, damage: 2 }),
            new Bullet({ x: player.x + 6, y: baseY, dir: player.bulletDir, speed: 980, r: 3, damage: 2 })
          ];
        }
      },
      minigun: {
        id: 'minigun',
        name: 'Mini Gun / Machinegun',
        cost: 60,
        bulletCost: 2,
        description: 'Machinegun stream of bolts. Great for screens full of foes.',
        hitscanShots: (x, y) => [
          { x: x - 18, y, pierce: 1 },
          { x: x - 4, y: y - 8, pierce: 1 },
          { x: x + 4, y: y + 8, pierce: 1 },
          { x: x + 18, y, pierce: 1 }
        ],
        projectiles: (player) => {
          const baseY = player.y + (player.bulletDir > 0 ? 10 : -10);
          return [
            new Bullet({ x: player.x - 18, y: baseY, dir: player.bulletDir, vx: -120, damage: 1, speed: 760, r: 3 }),
            new Bullet({ x: player.x - 6, y: baseY, dir: player.bulletDir, vx: -30, damage: 1, speed: 760, r: 3 }),
            new Bullet({ x: player.x + 6, y: baseY, dir: player.bulletDir, vx: 30, damage: 1, speed: 760, r: 3 }),
            new Bullet({ x: player.x + 18, y: baseY, dir: player.bulletDir, vx: 120, damage: 1, speed: 760, r: 3 })
          ];
        }
      }
    };

    const shopItems = [
      weaponCatalog.rifle,
      weaponCatalog.shotgun,
      weaponCatalog.x2boomgun,
      weaponCatalog.minigun,
      { id: 'nuke', name: 'Omega Nuke', cost: 100, description: 'Instantly vaporizes everything on screen.', type: 'nuke' }
    ];

    // Hardcoded question sets for each level
    const levelQuestions = {
      1: [
        { a:6, b:5, op:'+', answer:11 },
        { a:7, b:4, op:'+', answer:11 },
        { a:7, b:5, op:'+', answer:12 },
        { a:7, b:6, op:'+', answer:13 },
        { a:8, b:3, op:'+', answer:11 },
        { a:8, b:4, op:'+', answer:12 },
        { a:8, b:5, op:'+', answer:13 },
        { a:8, b:6, op:'+', answer:14 },
        { a:8, b:7, op:'+', answer:15 },
        { a:9, b:3, op:'+', answer:12 },
        { a:9, b:4, op:'+', answer:13 },
        { a:9, b:5, op:'+', answer:14 },
        { a:9, b:6, op:'+', answer:15 },
        { a:9, b:7, op:'+', answer:16 },
        { a:9, b:8, op:'+', answer:17 }
      ],
      2: [
        { a:11, b:2, op:'−', answer:9 },
        { a:11, b:3, op:'−', answer:8 },
        { a:11, b:4, op:'−', answer:7 },
        { a:11, b:5, op:'−', answer:6 },
        { a:11, b:6, op:'−', answer:5 },
        { a:11, b:7, op:'−', answer:4 },
        { a:11, b:8, op:'−', answer:3 },
        { a:11, b:9, op:'−', answer:2 },
        { a:12, b:3, op:'−', answer:9 },
        { a:12, b:4, op:'−', answer:8 },
        { a:12, b:5, op:'−', answer:7 },
        { a:12, b:7, op:'−', answer:5 },
        { a:12, b:8, op:'−', answer:4 },
        { a:12, b:9, op:'−', answer:3 },
        { a:13, b:4, op:'−', answer:9 },
        { a:13, b:5, op:'−', answer:8 },
        { a:13, b:6, op:'−', answer:7 },
        { a:13, b:7, op:'−', answer:6 },
        { a:13, b:8, op:'−', answer:5 },
        { a:13, b:9, op:'−', answer:4 },
        { a:14, b:5, op:'−', answer:9 },
        { a:14, b:6, op:'−', answer:8 },
        { a:14, b:8, op:'−', answer:6 },
        { a:14, b:9, op:'−', answer:5 },
        { a:15, b:6, op:'−', answer:9 },
        { a:15, b:7, op:'−', answer:8 },
        { a:15, b:8, op:'−', answer:7 },
        { a:15, b:9, op:'−', answer:6 },
        { a:16, b:7, op:'−', answer:9 },
        { a:16, b:9, op:'−', answer:7 },
        { a:17, b:8, op:'−', answer:9 },
        { a:17, b:9, op:'−', answer:8 }
      ],
      3: [
        { a:6, b:6, op:'×', answer:36 },
        { a:6, b:7, op:'×', answer:42 },
        { a:6, b:8, op:'×', answer:48 },
        { a:6, b:9, op:'×', answer:54 },
        { a:6, b:12, op:'×', answer:72 },
        { a:7, b:7, op:'×', answer:49 },
        { a:7, b:8, op:'×', answer:56 },
        { a:7, b:9, op:'×', answer:63 },
        { a:7, b:12, op:'×', answer:84 },
        { a:8, b:8, op:'×', answer:64 },
        { a:8, b:9, op:'×', answer:72 },
        { a:8, b:12, op:'×', answer:96 },
        { a:9, b:9, op:'×', answer:81 },
        { a:9, b:12, op:'×', answer:108 },
        { a:12, b:12, op:'×', answer:144 }
      ],
      4: [
        { a:4, b:11, op:'×', answer:44 },
        { a:4, b:12, op:'×', answer:48 },
        { a:5, b:11, op:'×', answer:55 },
        { a:5, b:12, op:'×', answer:60 },
        { a:6, b:11, op:'×', answer:66 },
        { a:6, b:12, op:'×', answer:72 },
        { a:7, b:11, op:'×', answer:77 },
        { a:7, b:12, op:'×', answer:84 },
        { a:8, b:11, op:'×', answer:88 },
        { a:8, b:12, op:'×', answer:96 },
        { a:9, b:11, op:'×', answer:99 },
        { a:9, b:12, op:'×', answer:108 },
        { a:10, b:11, op:'×', answer:110 },
        { a:10, b:12, op:'×', answer:120 },
        { a:11, b:11, op:'×', answer:121 },
        { a:11, b:12, op:'×', answer:132 },
        { a:12, b:11, op:'×', answer:132 },
        { a:12, b:12, op:'×', answer:144 }
      ]
    };

    const questionIndex = { 1:0, 2:0, 3:0, 4:0 };
    const levelGoalOverrides = { 2: 16 }; // shorten subtraction stage to 16 reloads

    function shuffleQuestionsForLevel(lvl) {
      const arr = levelQuestions[lvl];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // ===== Difficulty pacing per level =====
    // Level 1 (3D) keeps your original pacing
    const level1Params = { speedRange: [0.20, 0.35], spawnPerSec: 0.60, zStart: 360 };

    // ==== NEW: 2D mode parameters (pixels/second) ====
    const level2Params = { // Bat Cave
      spawnPerSec: 0.55,       // was 0.85 → fewer bats overall
      vyRange: [120, 180],
      ampRange: [30, 70],
      freqRange: [0.6, 1.1],   // was 1.2–2.0 → slower left-right sway
      hp: 1,
      touchDamage: 10
    };
    const level3Params = { // Neon Highway (driving)
      roadSpeed: 400,          // pixels/sec road scroll speed
      laneCount: 3,
      gateSpawnInterval: 17,   // seconds between answer gates (longer gaps)
      obstacleSpawnRate: 0.8,  // obstacles per second
      rivalCarRate: 0.3,       // rival cars per second
      obstacleDamage: 15,
      wrongAnswerDamage: 20
    };
    const level4Params = { // Space + Boss
      spawnPerSec: 1.15,
      vyRange: [150, 220],
      ampRange: [40, 90],
      freqRange: [1.5, 2.8],
      hp: 1,
      touchDamage: 12
    };

    const bossConfigs = {
      1: { hp: 10, speed: 90, color: '#ff77aa', glow: '#ffcc33', bar: '#ffdd66', size: 60, hoverY: 140 },
      2: { hp: 12, speed: 110, color: '#66e0ff', glow: '#33ffaa', bar: '#7affc5', size: 64, hoverY: 120 },
      3: { hp: 14, speed: 180, color: '#ff4444', glow: '#ff6666', bar: '#ff8888', size: 50, hoverY: null, isPolice: true },
      4: { hp: 16, speed: 120, color: '#ffd54d', glow: '#ff3', bar: '#ff3', size: 72, hoverY: 120 }
    };

    function showBanner(text, ms=1200) {
      levelBanner.textContent = text;
      levelBanner.style.display = 'block';
      setTimeout(() => levelBanner.style.display = 'none', ms);
    }
    function syncSpeedFromSlider() {
      speedMultiplier = parseFloat(speedSlider.value);
      speedLabel.textContent = speedMultiplier.toFixed(1) + 'x';
    }

    function updateUI() {
      if (health <= 0 && lives > 0) {
        lives--;
        if (lives > 0) {
          health = 100;
        } else if (gameRunning) {
          gameOver();
        }
      }
      scoreEl.textContent = score;
      bulletsEl.textContent = bullets;
      coinsEl.textContent = coins;
      healthEl.textContent = Math.max(0, health);
      livesEl.innerHTML = '❤️'.repeat(lives);
      levelEl.textContent = level;
      progressEl.textContent = correctThisLevel;
      levelGoalEl.textContent = levelGoal;
      const weapon = weaponCatalog[currentWeapon];
      weaponNameEl.textContent = weapon ? weapon.name : 'Unknown';
      nukeCountEl.textContent = nukeCount;
      nukeRow.style.display = nukeCount > 0 ? 'flex' : 'none';
    }
    function grantChestCoins(x, y) {
      const reward = randInt(coinChestReward.min, coinChestReward.max);
      coins += reward;
      updateUI();
      explosions.push(new Explosion(x, y));
      showBanner(`Loot Chest: +${reward} coins!`, 1100);
    }
    function opForLevel(lvl) { return levelOps[lvl].sym; }

    function generateMathProblemForLevel(lvl) {
      const list = levelQuestions[lvl];
      const idx = questionIndex[lvl];
      if (!list || idx >= list.length) return null;
      return list[idx];
    }

    function showMathPrompt() {
      if (isReloading) return;
      if (questionIndex[level] >= levelQuestions[level].length) {
        bullets = bulletsPerReloadForLevel(level);
        updateUI();
        return;
      }
      isReloading = true;
      currentMathProblem = generateMathProblemForLevel(level);
      promptTitle.textContent = `RELOAD — Level ${level}: ${levelOps[level].name}`;
      mathQuestionEl.innerHTML = `${currentMathProblem.a} ${currentMathProblem.op} ${currentMathProblem.b} = ?`;
      mathPrompt.style.display = 'block';
      mathAnswerEl.value = '';
      mathAnswerEl.focus();
    }

    // Boss gate: each level ends with a boss. Progress stays capped at levelGoal until
    // the boss for that level is defeated.
    let boss = null;
    
    function bulletsPerReloadForLevel(lvl) {
      return (lvl === 2) ? 15 : bulletsPerReload; // L2 gets 15, others keep default 10
    }
    function checkAnswer() {
      const val = mathAnswerEl.value.trim();
      if (val === '') return;
      const answer = Number(val);
      if (Number.isNaN(answer)) return;

      if (answer === currentMathProblem.answer) {
        questionIndex[level]++;
        bullets = bulletsPerReloadForLevel(level);
        if (!boss && !levelCleared) { // while boss alive/cleared, don't add progress past goal
          correctThisLevel = Math.min(levelGoal, correctThisLevel + 1);
        }
        updateUI();

        if (correctThisLevel >= levelGoal && !boss && !levelCleared) {
          spawnBoss(level);
        }

        mathPrompt.style.display = 'none';
        isReloading = false;
      } else {
        mathAnswerEl.style.borderColor = '#ff0000';
        setTimeout(() => {
          mathAnswerEl.style.borderColor = '#00ff00';
          mathAnswerEl.value = '';
          mathAnswerEl.focus();
        }, 350);
      }
    }

    function gameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverEl.style.display = 'block';
    }
    function winGame() {
      gameRunning = false;
      finalWinScoreEl.textContent = score;
      youWinEl.style.display = 'block';
    }

    function handleBossDefeated(defeatedLevel, x, y) {
      levelCleared = true;
      const cfg = bossConfigs[defeatedLevel] || bossConfigs[4];
      bossDefeatFx.push(new BossDefeatAnimation(x, y, cfg));
      targets = [];
      enemies2D = [];
      projectiles = [];
      heartSpawnActive = false;

      const delay = 900;
      if (defeatedLevel >= maxLevel) {
        setTimeout(() => winGame(), delay);
      } else {
        setTimeout(() => {
          coins += coinsPerLevel;
          const nextLevel = defeatedLevel + 1;
          level = nextLevel;
          correctThisLevel = 0;
          pendingLevel = nextLevel;
          const overrideGoal = levelGoalOverrides[nextLevel];
          levelGoal = overrideGoal ?? levelQuestions[nextLevel].length;
          updateUI();
          openShop();
        }, delay);
      }
    }

    function restartGame() {
      score = 0;
      bullets = bulletsPerReload;
      coins = 0;
      health = 100;
      lives = 3;
      targets = [];
      explosions = [];
      hearts = [];
      coinChests3D = [];
      coinChests2D = [];
      bossDefeatFx = [];
      heartSpawnActive = false;
      heartSpawnTimer = 0;
      enemies2D = [];
      projectiles = [];
      answerGates = [];
      roadObstacles = [];
      rivalCars = [];
      drivingBullets = [];
      drivingLane = 1;
      roadScrollOffset = 0;
      gateSpawnTimer = 0;
      drivingSpeed = 1.0;
      activeGateProblem = null;
      boss = null;
      gameRunning = true;
      isReloading = false;
      isPaused = false;
      level = 1;
      correctThisLevel = 0;
      levelCleared = false;
      currentWeapon = 'blaster';
      ownedWeapons.clear();
      ownedWeapons.add('blaster');
      nukeCount = 0;
      pendingLevel = null;
      for (let k in questionIndex) questionIndex[k] = 0;
      lastTime = 0;
      gameOverEl.style.display = 'none';
      youWinEl.style.display = 'none';
      mathPrompt.style.display = 'none';
      pauseScreen.style.display = 'none';
      shopScreen.style.display = 'none';
      syncSpeedFromSlider();
      configureLevel(1);
      updateUI();
      showBanner(`Level ${level}: ${levelOps[level].name}`);
    }

    function togglePause() {
      if (!isPaused && (!gameRunning || startScreen.style.display !== 'none')) return;
      isPaused = !isPaused;
      gameRunning = !isPaused;
      if (isPaused) {
        pauseScreen.style.display = 'block';
        player.moveLeft = false; player.moveRight = false;
      } else {
        pauseScreen.style.display = 'none';
      }
    }

    // ===== ENTITIES — Level 1 (3D skulls, original Target) =====
    class Target {
      constructor(params) {
        this.x = (Math.random() - 0.5) * 200;
        this.y = (Math.random() - 0.5) * 100;
        this.z = params.zStart;
        this.baseSpeed = randRange(params.speedRange[0], params.speedRange[1]); // per-frame at 60fps baseline
        this.size = 20;
        this.hit = false;
      }
      update(dt) {
        if (!this.hit) {
          this.z -= this.baseSpeed * speedMultiplier * dt;
          if (this.z <= 1) { health -= 10; updateUI(); return false; }
        }
        return true;
      }
      getScreenCoords() {
        const scale = 200 / Math.max(1, this.z);
        const screenX = vanishingPoint.x + (this.x * scale);
        const screenY = vanishingPoint.y + (this.y * scale);
        const screenSize = this.size * scale;
        return { x: screenX, y: screenY, size: screenSize };
      }
      draw() {
        const c = this.getScreenCoords();
        ctx.save();
        const size = c.size;
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = size * 0.5;

        // Skull cranium
        ctx.fillStyle = '#f0f0f0';
        ctx.beginPath(); ctx.arc(c.x, c.y - size * 0.2, size * 0.8, 0, Math.PI * 2); ctx.fill();
        // Jaw
        ctx.beginPath(); ctx.ellipse(c.x, c.y + size * 0.3, size * 0.6, size * 0.5, 0, 0, Math.PI * 2); ctx.fill();
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.ellipse(c.x - size * 0.25, c.y - size * 0.2, size * 0.2, size * 0.25, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(c.x + size * 0.25, c.y - size * 0.2, size * 0.2, size * 0.25, 0, 0, Math.PI * 2); ctx.fill();
        // Eye glow
        ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(c.x - size * 0.25, c.y - size * 0.2, size * 0.05, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(c.x + size * 0.25, c.y - size * 0.2, size * 0.05, 0, Math.PI * 2); ctx.fill();
        // Nose
        ctx.fillStyle = '#000'; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.moveTo(c.x, c.y); ctx.lineTo(c.x - size * 0.1, c.y + size * 0.15); ctx.lineTo(c.x + size * 0.1, c.y + size * 0.15);
        ctx.closePath(); ctx.fill();
        // Teeth
        ctx.fillStyle = '#f0f0f0'; ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        const teethCount = 6; const teethWidth = (size * 0.6) / teethCount;
        for (let i = 0; i < teethCount; i++) {
          const x = c.x - size * 0.3 + i * teethWidth + teethWidth / 2;
          ctx.fillRect(x - teethWidth * 0.3, c.y + size * 0.35, teethWidth * 0.6, size * 0.15);
          ctx.strokeRect(x - teethWidth * 0.3, c.y + size * 0.35, teethWidth * 0.6, size * 0.15);
        }
        // Crack
        ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(c.x - size * 0.1, c.y - size * 0.6); ctx.lineTo(c.x - size * 0.05, c.y - size * 0.3); ctx.stroke();
        ctx.restore();
      }
      checkHit(x, y) {
        const c = this.getScreenCoords();
        const dist = Math.hypot(x - c.x, y - c.y);
        return dist < c.size;
      }
    }

    class Explosion {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.particles = [];
        for (let i = 0; i < 15; i++) {
          this.particles.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 1 });
        }
      }
      update(dt) {
        this.particles = this.particles.filter(p => {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 0.2 * dt;    // gravity-ish
          p.life -= 0.03 * dt; // fade rate
          return p.life > 0;
        });
        return this.particles.length > 0;
      }
      draw() {
        this.particles.forEach(p => {
          ctx.fillStyle = `rgba(0, 255, ${Math.floor(p.life * 100)}, ${p.life})`;
          ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 10;
          ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        });
        ctx.shadowBlur = 0;
      }
    }

    class BossDefeatAnimation {
      constructor(x, y, cfg) {
        this.x = x; this.y = y;
        this.cfg = cfg;
        this.time = 0;
        this.duration = 1.25;
        this.sparks = Array.from({length: 55}, () => ({
          x, y,
          vx: randRange(-220, 220),
          vy: randRange(-120, 160),
          life: randRange(0.6, 1),
          size: randRange(2, 4)
        }));
      }
      update(deltaSec) {
        this.time += deltaSec;
        this.sparks = this.sparks.filter(s => {
          s.x += s.vx * deltaSec;
          s.y += s.vy * deltaSec;
          s.vy += 280 * deltaSec * 0.25;
          s.life -= deltaSec * 0.6;
          return s.life > 0;
        });
        return this.time < this.duration || this.sparks.length > 0;
      }
      draw() {
        const progress = clamp(this.time / this.duration, 0, 1);
        const ringRadius = 40 + progress * 160;
        ctx.save();
        ctx.strokeStyle = this.cfg.glow;
        ctx.lineWidth = 6 * (1 - progress);
        ctx.globalAlpha = 0.9 * (1 - progress);
        ctx.beginPath(); ctx.arc(this.x, this.y, ringRadius, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(this.x, this.y, ringRadius * 0.6, 0, Math.PI*2); ctx.stroke();

        this.sparks.forEach(s => {
          ctx.globalAlpha = clamp(s.life, 0, 1);
          ctx.fillStyle = this.cfg.color;
          ctx.shadowColor = this.cfg.glow; ctx.shadowBlur = 14;
          ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    // ===== Backgrounds (Level 1 canyon as-is) =====
    const tombstones = [];
    function initDecor() {
      tombstones.length = 0;
      for (let i = 0; i < 60; i++) {
        const x = Math.random() * canvas.width;
        const y = vanishingPoint.y + Math.random() * (canvas.height - vanishingPoint.y);
        const size = 2 + (y - vanishingPoint.y) / (canvas.height - vanishingPoint.y) * 4;
        tombstones.push({ x, y, size });
      }
    }
    function drawCanyon() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#000000');
      gradient.addColorStop(0.5, '#001a00');
      gradient.addColorStop(1, '#003300');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const fogGradient = ctx.createRadialGradient(vanishingPoint.x, vanishingPoint.y, 0, vanishingPoint.x, vanishingPoint.y, canvas.width);
      fogGradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
      fogGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = fogGradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = '#004400'; ctx.lineWidth = 2; ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 5;

      for (let i = 0; i <= 10; i++) {
        const lx = (i / 10) * vanishingPoint.x;
        ctx.beginPath(); ctx.moveTo(lx, canvas.height); ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(lx, 0);             ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();

        const rx = vanishingPoint.x + (i / 10) * (canvas.width - vanishingPoint.x);
        ctx.beginPath(); ctx.moveTo(rx, canvas.height); ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rx, 0);             ctx.lineTo(vanishingPoint.x, vanishingPoint.y); ctx.stroke();
      }
      for (let i = 1; i <= 8; i++) {
        const f = i / 8;
        const left = vanishingPoint.x - (vanishingPoint.x * f);
        const right = vanishingPoint.x + ((canvas.width - vanishingPoint.x) * f);
        const top = vanishingPoint.y - (vanishingPoint.y * f);
        const bottom = vanishingPoint.y + ((canvas.height - vanishingPoint.y) * f);
        ctx.beginPath(); ctx.moveTo(left, top); ctx.lineTo(right, top); ctx.lineTo(right, bottom); ctx.lineTo(left, bottom);
        ctx.closePath(); ctx.stroke();
      }
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#002200';
      tombstones.forEach(t => {
        ctx.fillRect(t.x - t.size / 2, t.y - t.size, t.size, t.size);
        ctx.beginPath(); ctx.arc(t.x, t.y - t.size, t.size / 2, Math.PI, 0); ctx.fill();
      });
    }

    // ===== NEW: 2D mode (enemies, player, bullets) =====
    let enemies2D = [];
    let projectiles = [];

    const player = {
      x: canvas.width * 0.5,
      y: canvas.height - 60, // bottom by default (L2, L4)
      w: 26, h: 26,
      speed: 480, // px/s
      moveLeft: false, moveRight: false,
      topMode: false,       // L3 puts the ship at the top
      bulletDir: -1,        // up on L2/L4, down on L3
    };
    function clampPlayer() {
      player.x = clamp(player.x, 30, canvas.width - 30);
      player.y = player.topMode ? 60 : canvas.height - 60;
    }
    function drawShip() {
      const x = player.x, y = player.y, s = 18;
      ctx.save();

      if (currentWeapon === 'x2boomgun') {
        const dir = player.bulletDir;
        const startY = dir < 0 ? y - s * 0.9 : y + s * 0.9;
        const endY = dir < 0 ? 24 : canvas.height - 24;
        const guide = ctx.createLinearGradient(x, startY, x, endY);
        if (dir < 0) {
          guide.addColorStop(0, 'rgba(120, 255, 255, 0.65)');
          guide.addColorStop(1, 'rgba(120, 255, 255, 0)');
        } else {
          guide.addColorStop(0, 'rgba(120, 255, 255, 0)');
          guide.addColorStop(1, 'rgba(120, 255, 255, 0.65)');
        }
        ctx.strokeStyle = guide;
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 14]);
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      if (currentMode === Modes.JELLIES) {
        // Water background under the ship
        const waterTop = y + s * 0.9;
        ctx.fillStyle = 'rgba(0,80,160,0.4)';
        ctx.fillRect(0, waterTop, canvas.width, canvas.height - waterTop);
        ctx.strokeStyle = '#00aaff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, waterTop);
        ctx.lineTo(canvas.width, waterTop);
        ctx.stroke();

        // Simple boat hull
        ctx.fillStyle = '#b5651d';
        ctx.beginPath();
        ctx.moveTo(x - s, y);
        ctx.lineTo(x + s, y);
        ctx.lineTo(x + s * 0.6, y + s * 0.8);
        ctx.lineTo(x - s * 0.6, y + s * 0.8);
        ctx.closePath();
        ctx.fill();

        // Cabin / mast
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(x, y - s);
        ctx.lineTo(x, y);
        ctx.lineTo(x + s * 0.6, y);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.shadowColor = currentMode === Modes.BATS ? '#ff7a00' : '#7afcff';
        ctx.shadowBlur = 15;
        ctx.fillStyle = currentMode === Modes.BATS ? '#ffa64d' : '#aef';
        ctx.beginPath();
        ctx.moveTo(x, y - s);
        ctx.lineTo(x - s * 0.7, y + s * 0.9);
        ctx.lineTo(x + s * 0.7, y + s * 0.9);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.restore();
    }

    function drawPlayerCar() {
      const x = getLaneX(drivingLane);
      const y = canvas.height - 80;

      ctx.save();
      // Car body
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#00cccc';
      ctx.fillRect(x - 20, y - 35, 40, 70);

      // Hood gradient
      ctx.fillStyle = '#00aaaa';
      ctx.fillRect(x - 18, y - 30, 36, 25);

      // Windshield
      ctx.fillStyle = '#003344';
      ctx.fillRect(x - 14, y - 22, 28, 18);

      // Headlights
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 12;
      ctx.fillRect(x - 16, y - 33, 8, 5);
      ctx.fillRect(x + 8, y - 33, 8, 5);

      // Taillights
      ctx.fillStyle = '#ff0000';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 8;
      ctx.fillRect(x - 16, y + 28, 8, 5);
      ctx.fillRect(x + 8, y + 28, 8, 5);

      // Neon underglow
      ctx.shadowColor = '#ff00ff';
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#ff00ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x - 22, y + 35);
      ctx.lineTo(x + 22, y + 35);
      ctx.stroke();

      ctx.restore();
    }

    class Bullet {
      constructor({ x, y, dir, speed, r, damage, vx }) {
        this.x = x;
        this.y = y;
        this.dir = dir; // -1 up, +1 down
        this.speed = speed ?? (currentMode === Modes.JELLIES ? 200 : 620);
        this.r = r ?? (currentMode === Modes.JELLIES ? 6 : 3.5);
        this.damage = damage ?? 1;
        this.vx = vx ?? 0;
      }
      update(deltaSec) {
        this.x += this.vx * deltaSec;
        this.y += this.dir * this.speed * deltaSec; // bullets ignore slow-mo
        return (this.y > -40 && this.y < canvas.height + 40 && this.x > -40 && this.x < canvas.width + 40);
      }
      draw() {
        if (currentMode === Modes.JELLIES) {
          ctx.fillStyle = '#ddd';
          ctx.fillRect(this.x - 3, this.y - 8, 6, 16);
          ctx.fillStyle = '#f00';
          ctx.fillRect(this.x - 5, this.y + 8, 10, 4);
        } else {
          ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        }
      }
    }

    class Heart {
      constructor() {
        // In driving mode, spawn hearts in lanes
        if (currentMode === Modes.DRIVING) {
          this.lane = randInt(0, 2);
          this.vy = level3Params.roadSpeed * 0.8; // Move with road speed
          this.isDriving = true;
        } else {
          this.x = randInt(30, canvas.width - 30);
          this.vy = 60;
          this.isDriving = false;
        }
        this.y = -40;
        this.r = 16;
      }
      update(deltaSec) {
        const speed = this.isDriving ? this.vy * drivingSpeed : this.vy;
        this.y += speed * speedMultiplier * deltaSec;
        return this.y < canvas.height + 40;
      }
      draw() {
        ctx.save();
        ctx.fillStyle = '#ff4d4d';

        let x, r;
        if (this.isDriving) {
          // Use perspective positioning in driving mode
          const persp = getPerspective(this.lane, this.y);
          x = persp.x;
          r = this.r * persp.scale;
          ctx.shadowColor = '#ff4d4d'; ctx.shadowBlur = 20 * persp.scale;
        } else {
          x = this.x;
          r = this.r;
          ctx.shadowColor = '#ff4d4d'; ctx.shadowBlur = 20;
        }

        const y = this.y;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + r, y - r, x + r*2, y + r, x, y + r*2);
        ctx.bezierCurveTo(x - r*2, y + r, x - r, y - r, x, y);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
      }
      hitTest(px, py, pr=0) {
        let heartX;
        if (this.isDriving) {
          const persp = getPerspective(this.lane, this.y);
          heartX = persp.x;
        } else {
          heartX = this.x;
        }
        return Math.hypot(heartX - px, this.y - py) < (this.r + pr);
      }
    }

    class CoinChest3D {
      constructor(params) {
        this.z = params.zStart;
        this.x = (Math.random() - 0.5) * 180;
        this.y = (Math.random() - 0.5) * 90;
        this.baseSpeed = randRange(params.speedRange[0] * 0.65, params.speedRange[1] * 0.85);
        this.size = 24;
      }
      update(dt) {
        this.z -= this.baseSpeed * speedMultiplier * dt;
        return this.z > 1.2;
      }
      getScreenCoords() {
        const scale = 200 / Math.max(1.2, this.z);
        const screenX = vanishingPoint.x + (this.x * scale);
        const screenY = vanishingPoint.y + (this.y * scale);
        const screenSize = this.size * scale;
        return { x: screenX, y: screenY, size: screenSize };
      }
      draw() {
        const c = this.getScreenCoords();
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.shadowColor = '#ffd966'; ctx.shadowBlur = c.size * 0.5;
        ctx.fillStyle = '#a6692a';
        const boxW = c.size * 1.4;
        const boxH = c.size * 0.9;
        ctx.fillRect(-boxW/2, -boxH/2, boxW, boxH);
        ctx.fillStyle = '#d48836';
        ctx.fillRect(-boxW/2, -boxH*0.2, boxW, boxH*0.4);
        ctx.fillStyle = '#ffd966';
        ctx.fillRect(-4, -boxH/2, 8, boxH);
        ctx.strokeStyle = '#ffd966'; ctx.lineWidth = 2;
        ctx.strokeRect(-boxW/2, -boxH/2, boxW, boxH);
        ctx.restore();
      }
      checkHit(x, y) {
        const c = this.getScreenCoords();
        const dx = Math.abs(x - c.x);
        const dy = Math.abs(y - c.y);
        return dx < c.size * 0.8 && dy < c.size * 0.6;
      }
    }

    class CoinChest2D {
      constructor(mode) {
        this.mode = mode;
        this.x = randInt(40, canvas.width - 40);
        this.radius = 20;
        if (mode === Modes.JELLIES) {
          this.y = canvas.height + 40;
          this.vy = -randRange(70, 110);
        } else {
          this.y = -40;
          this.vy = randRange(70, 110);
        }
      }
      update(deltaSec) {
        this.y += this.vy * speedMultiplier * deltaSec;
        if (this.mode === Modes.JELLIES) {
          return this.y > -60;
        }
        return this.y < canvas.height + 60;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowColor = '#ffd966'; ctx.shadowBlur = 18;
        ctx.fillStyle = '#a6692a';
        ctx.fillRect(-22, -16, 44, 28);
        ctx.fillStyle = '#d48836';
        ctx.fillRect(-22, -4, 44, 12);
        ctx.fillStyle = '#ffd966';
        ctx.fillRect(-4, -16, 8, 28);
        ctx.strokeStyle = '#ffd966'; ctx.lineWidth = 2;
        ctx.strokeRect(-22, -16, 44, 28);
        ctx.restore();
      }
      hitTest(px, py, pr=0) {
        return Math.hypot(this.x - px, this.y - py) < (this.radius + pr);
      }
    }

    // ---- Enemy types for 2D modes ----
    class Bat {
      constructor() {
        this.x0 = randInt(30, canvas.width - 30);
        this.y = -40; // top
        this.amp = randRange(level2Params.ampRange[0], level2Params.ampRange[1]);
        this.freq = randRange(level2Params.freqRange[0], level2Params.freqRange[1]);
        this.vy = randRange(level2Params.vyRange[0], level2Params.vyRange[1]);
        this.hp = level2Params.hp;
        this.t = Math.random()*10;
        this.r = 18;
      }
      update(deltaSec) {
        this.t += deltaSec;
        this.x = this.x0 + Math.sin(this.t * Math.PI * 2 * this.freq) * this.amp;
        this.y += this.vy * speedMultiplier * deltaSec;
        // Touch bottom line (player row) => damage
        if (this.y >= canvas.height - 24) { health -= level2Params.touchDamage; updateUI(); return false; }
        return true;
      }
      draw() {
        // orange-glow bat
        ctx.save();
        ctx.shadowColor = '#ff7a00'; ctx.shadowBlur = 22;
        ctx.fillStyle = '#ff7a00';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 4);
        ctx.quadraticCurveTo(this.x - 20, this.y + 10, this.x - 10, this.y + 16);
        ctx.lineTo(this.x, this.y + 4);
        ctx.lineTo(this.x + 10, this.y + 16);
        ctx.quadraticCurveTo(this.x + 20, this.y + 10, this.x, this.y - 4);
        ctx.fill();
        ctx.shadowBlur = 0;
        // eyes
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(this.x - 4, this.y + 4, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(this.x + 4, this.y + 4, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class Jelly {
      constructor() {
        this.x = randInt(30, canvas.width - 30);
        this.y = canvas.height + 40; // from bottom, going up
        this.vy = -randRange(level3Params.vyRange[0], level3Params.vyRange[1]);
        this.vx = randRange(level3Params.driftRange[0], level3Params.driftRange[1]);
        this.hp = level3Params.hp;
        this.r = 20;
        this.pulse = Math.random()*Math.PI*2;
      }
      update(deltaSec) {
        this.pulse += deltaSec*2;
        this.x += this.vx * speedMultiplier * deltaSec;
        this.y += this.vy * speedMultiplier * deltaSec;
        if (this.y <= 24) { health -= level3Params.touchDamage; updateUI(); return false; }
        if (this.x < -30 || this.x > canvas.width + 30) return false;
        return true;
      }
      draw() {
        ctx.save();
        ctx.shadowColor = '#66ffd4'; ctx.shadowBlur = 18;
        ctx.fillStyle = '#66ffd4';
        const r = this.r * (0.9 + 0.1*Math.sin(this.pulse));
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, r*0.9, r*0.7, 0, 0, Math.PI*2); ctx.fill();
        // tendrils
        ctx.strokeStyle = '#44ddb8'; ctx.lineWidth = 2;
        for (let i=-2;i<=2;i++){
          ctx.beginPath();
          ctx.moveTo(this.x + i*4, this.y + r*0.3);
          ctx.quadraticCurveTo(this.x + i*6, this.y + r*0.6, this.x + i*3, this.y + r);
          ctx.stroke();
        }
        ctx.restore();
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class Alien {
      constructor() {
        this.x0 = randInt(30, canvas.width - 30);
        this.y = -40;
        this.amp = randRange(level4Params.ampRange[0], level4Params.ampRange[1]);
        this.freq = randRange(level4Params.freqRange[0], level4Params.freqRange[1]);
        this.vy = randRange(level4Params.vyRange[0], level4Params.vyRange[1]);
        this.hp = level4Params.hp;
        this.t = Math.random()*10;
        this.r = 18;
      }
      update(deltaSec) {
        this.t += deltaSec;
        this.x = this.x0 + Math.cos(this.t * Math.PI * 2 * this.freq) * this.amp;
        this.y += this.vy * speedMultiplier * deltaSec;
        if (this.y >= canvas.height - 24) { health -= level4Params.touchDamage; updateUI(); return false; }
        return true;
      }
      draw() {
        ctx.save();
        ctx.shadowColor = '#7afcff'; ctx.shadowBlur = 22;
        ctx.fillStyle = '#9fe6ff';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 18, 12, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#003f5c';
        ctx.beginPath(); ctx.ellipse(this.x, this.y, 8, 6, 0, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
      hitTest(px, py, pr) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    class Boss {
      constructor(level) {
        this.level = level;
        const cfg = bossConfigs[level] || bossConfigs[4];
        this.cfg = cfg;
        const hoverY = cfg.hoverY ?? (level === 3 ? canvas.height * 0.32 : 120);
        this.x = canvas.width/2; this.y = hoverY;
        this.vx = cfg.speed; this.dir = 1;
        this.maxHp = cfg.hp;
        this.hp = cfg.hp;
        this.r = cfg.size ?? 42;
      }
      update(deltaSec) {
        this.x += this.dir * this.vx * speedMultiplier * deltaSec;
        if (this.x < 60) { this.x = 60; this.dir = 1; }
        if (this.x > canvas.width - 60) { this.x = canvas.width - 60; this.dir = -1; }
      }
      draw() {
        const pulse = 1 + Math.sin(performance.now()/240) * 0.06;
        ctx.save();
        ctx.shadowColor = this.cfg.glow;
        ctx.shadowBlur = 32;
        ctx.fillStyle = this.cfg.color;
        ctx.beginPath(); ctx.ellipse(this.x, this.y, this.r * 1.2 * pulse, this.r * 0.75 * pulse, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(this.x - this.r*0.35, this.y - 8, 9, 0, Math.PI*2); ctx.arc(this.x + this.r*0.35, this.y - 8, 9, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.cfg.glow;
        ctx.beginPath(); ctx.arc(this.x - this.r*0.32, this.y - 8, 4, 0, Math.PI*2); ctx.arc(this.x + this.r*0.32, this.y - 8, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#222';
        ctx.fillRect(this.x-18, this.y+10, 36, 5);
        ctx.restore();

        // Boss health bar
        const w = 240, h = 8, x = canvas.width/2 - w/2, y = 24;
        ctx.strokeStyle = this.cfg.bar;
        ctx.strokeRect(x, y, w, h);
        const frac = clamp(this.hp / this.maxHp, 0, 1);
        ctx.fillStyle = this.cfg.bar;
        ctx.fillRect(x, y, w*frac, h);
      }
      hitTest(px, py, pr=0) { return Math.hypot(this.x - px, this.y - py) < (this.r + pr); }
    }

    // ===== NEW: 2D backgrounds =====
    function drawBatCaveBG() {
      // Dark center with orange border glow (like your screenshot)
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.width*0.2, canvas.width/2, canvas.height/2, canvas.width*0.8);
      g.addColorStop(0,'rgba(0,0,0,0.6)'); g.addColorStop(1,'rgba(0,0,0,1)'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
      // Frame glow
      ctx.shadowColor = '#ff7a00'; ctx.shadowBlur = 35; ctx.strokeStyle = '#ff7a00'; ctx.lineWidth = 6;
      ctx.strokeRect(20,20,canvas.width-40,canvas.height-40);
      ctx.shadowBlur = 0;
    }
    function drawSwampBG() {
      const g = ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,'#001015'); g.addColorStop(0.5,'#002b2b'); g.addColorStop(1,'#003a2a');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
      // Murky bubbles
      for (let i=0;i<12;i++){
        const x = (i/11)*canvas.width + Math.sin(i)*40, y = canvas.height*0.6 + (i%2)*40;
        ctx.fillStyle = 'rgba(80,180,140,0.08)'; ctx.beginPath(); ctx.arc(x,y, randRange(14,38), 0, Math.PI*2); ctx.fill();
      }
    }

    // ===== Neon Highway Background (Level 3) =====
    let roadLines = [];
    function initRoadLines() {
      roadLines = [];
      for (let i = 0; i < 20; i++) {
        roadLines.push({ y: i * 60 });
      }
    }

    function getLaneX(lane) {
      const roadWidth = Math.min(400, canvas.width * 0.6);
      const laneWidth = roadWidth / 3;
      const roadLeft = (canvas.width - roadWidth) / 2;
      return roadLeft + laneWidth * lane + laneWidth / 2;
    }

    // Perspective helper: returns X position and scale for objects on the road
    function getPerspective(lane, yPos) {
      const horizonY = canvas.height * 0.25;
      const bottomY = canvas.height;
      const roadWidthBottom = Math.min(400, canvas.width * 0.6);
      const roadWidthHorizon = 40; // Width at horizon (vanishing point)

      // Clamp Y to valid range
      const clampedY = Math.max(horizonY, Math.min(bottomY, yPos));

      // Calculate progress from horizon (0) to bottom (1)
      const progress = (clampedY - horizonY) / (bottomY - horizonY);

      // Interpolate road width based on perspective
      const currentRoadWidth = roadWidthHorizon + (roadWidthBottom - roadWidthHorizon) * progress;
      const laneWidth = currentRoadWidth / 3;
      const roadLeft = (canvas.width - currentRoadWidth) / 2;

      // Calculate X position for this lane at this Y
      const x = roadLeft + laneWidth * lane + laneWidth / 2;

      // Scale factor (smaller near horizon, larger near bottom)
      const scale = 0.2 + 0.8 * progress;

      return { x, scale, progress };
    }

    function drawHighwayBG(deltaSec) {
      // Dark purple sky
      const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGrad.addColorStop(0, '#1a0033');
      skyGrad.addColorStop(0.5, '#330044');
      skyGrad.addColorStop(1, '#220033');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars in the sky
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 40; i++) {
        const sx = (i * 137 + roadScrollOffset * 0.02) % canvas.width;
        const sy = (i * 73) % (canvas.height * 0.4);
        ctx.fillRect(sx, sy, 1.5, 1.5);
      }

      // Road dimensions
      const roadWidth = Math.min(400, canvas.width * 0.6);
      const roadLeft = (canvas.width - roadWidth) / 2;
      const roadRight = roadLeft + roadWidth;
      const horizonY = canvas.height * 0.25;

      // Road surface with perspective gradient
      const roadGrad = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
      roadGrad.addColorStop(0, '#1a1a2e');
      roadGrad.addColorStop(1, '#2d2d44');
      ctx.fillStyle = roadGrad;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 - 20, horizonY);
      ctx.lineTo(canvas.width / 2 + 20, horizonY);
      ctx.lineTo(roadRight, canvas.height);
      ctx.lineTo(roadLeft, canvas.height);
      ctx.closePath();
      ctx.fill();

      // Neon road edges
      ctx.shadowColor = '#ff00ff';
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#ff00ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 - 20, horizonY);
      ctx.lineTo(roadLeft, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 + 20, horizonY);
      ctx.lineTo(roadRight, canvas.height);
      ctx.stroke();

      // Lane dividers (dashed, scrolling)
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 3;
      ctx.setLineDash([30, 40]);

      const scrollSpeed = level3Params.roadSpeed * speedMultiplier * drivingSpeed;
      roadScrollOffset = (roadScrollOffset + scrollSpeed * deltaSec) % 70;

      // Draw scrolling lane markers
      const laneWidth = roadWidth / 3;
      for (let lane = 1; lane < 3; lane++) {
        const topX = canvas.width / 2 + (lane - 1.5) * 12;
        const bottomX = roadLeft + laneWidth * lane;

        ctx.lineDashOffset = -roadScrollOffset;
        ctx.beginPath();
        ctx.moveTo(topX, horizonY + 20);
        ctx.lineTo(bottomX, canvas.height);
        ctx.stroke();
      }

      ctx.setLineDash([]);
      ctx.shadowBlur = 0;
    }

    // ===== Driving Level Classes =====
    class AnswerGate {
      constructor(answers, correctIndex, problem) {
        this.y = -80;
        this.answers = answers; // array of 3 numbers
        this.correctIndex = correctIndex; // which lane has correct answer
        this.problem = problem;
        this.speed = level3Params.roadSpeed;
        this.passed = false;
        this.height = 60;
      }
      update(deltaSec) {
        this.y += this.speed * speedMultiplier * drivingSpeed * deltaSec;
        return this.y < canvas.height + 100;
      }
      draw() {
        // Use uniform cyan color for all gates (player must guess the correct answer)
        const gateColor = '#00ffff';

        for (let i = 0; i < 3; i++) {
          // Get perspective-correct position and scale for this gate
          const persp = getPerspective(i, this.y);
          const x = persp.x;
          const scale = persp.scale;

          // Scale gate dimensions based on perspective
          const gateWidth = 90 * scale;
          const gateHeight = 70 * scale;
          const fontSize = Math.max(16, Math.floor(38 * scale));

          ctx.save();
          ctx.shadowColor = gateColor;
          ctx.shadowBlur = 25 * scale;

          // Gate background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(x - gateWidth / 2, this.y - gateHeight / 2, gateWidth, gateHeight);

          // Gate border
          ctx.strokeStyle = gateColor;
          ctx.lineWidth = Math.max(2, 5 * scale);
          ctx.strokeRect(x - gateWidth / 2, this.y - gateHeight / 2, gateWidth, gateHeight);

          // Answer number - scaled font
          ctx.fillStyle = gateColor;
          ctx.font = `bold ${fontSize}px "Courier New", monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(this.answers[i], x, this.y);
          ctx.restore();
        }

        // Draw the problem prominently - positioned lower for visibility
        if (this.y < canvas.height * 0.7) {
          ctx.save();
          const problemText = `${this.problem.a} × ${this.problem.b} = ?`;

          // Draw background box for visibility - positioned lower on screen
          ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 30;
          const boxWidth = 320;
          const boxHeight = 80;
          const boxY = canvas.height * 0.18; // Positioned lower (was 25px from top)
          ctx.fillRect(canvas.width / 2 - boxWidth / 2, boxY, boxWidth, boxHeight);
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 3;
          ctx.strokeRect(canvas.width / 2 - boxWidth / 2, boxY, boxWidth, boxHeight);

          // Draw the math problem text - large and centered
          ctx.fillStyle = '#ffffff';
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 20;
          ctx.font = 'bold 48px "Courier New", monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(problemText, canvas.width / 2, boxY + boxHeight / 2);
          ctx.restore();
        }
      }
      checkCollision(playerLane, playerY) {
        if (this.passed) return null;
        const gateTop = this.y - 35;
        const gateBottom = this.y + 35;
        if (playerY >= gateTop && playerY <= gateBottom + 40) {
          this.passed = true;
          return playerLane === this.correctIndex;
        }
        return null;
      }
    }

    // Bullets for driving mode
    class DrivingBullet {
      constructor(lane) {
        this.lane = lane;
        this.x = getLaneX(lane);
        this.y = canvas.height - 100;
        this.speed = 600;
        this.r = 6;
      }
      update(deltaSec) {
        this.y -= this.speed * deltaSec;
        return this.y > -20;
      }
      draw() {
        ctx.save();
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, 4, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      checkHit(targetY, targetLane) {
        if (this.lane !== targetLane) return false;
        return Math.abs(this.y - targetY) < 30;
      }
      checkHitBoss(boss) {
        const dx = Math.abs(this.x - boss.x);
        const dy = Math.abs(this.y - boss.y);
        return dx < 40 && dy < 45;
      }
    }

    let drivingBullets = [];

    class RoadObstacle {
      constructor() {
        this.lane = randInt(0, 2);
        this.y = -60;
        this.width = 50;
        this.height = 30;
        this.speed = level3Params.roadSpeed;
        this.type = Math.random() < 0.5 ? 'barrier' : 'cone';
      }
      update(deltaSec) {
        this.y += this.speed * speedMultiplier * drivingSpeed * deltaSec;
        return this.y < canvas.height + 60;
      }
      draw() {
        // Get perspective-correct position and scale
        const persp = getPerspective(this.lane, this.y);
        const x = persp.x;
        const scale = persp.scale;
        ctx.save();

        if (this.type === 'barrier') {
          // Orange/white striped barrier with perspective scaling
          const barrierWidth = 50 * scale;
          const barrierHeight = 24 * scale;
          ctx.shadowColor = '#ff6600';
          ctx.shadowBlur = 12 * scale;
          ctx.fillStyle = '#ff6600';
          ctx.fillRect(x - barrierWidth / 2, this.y - barrierHeight / 2, barrierWidth, barrierHeight);
          ctx.fillStyle = '#ffffff';
          const stripeWidth = 7 * scale;
          const stripeSpacing = 14 * scale;
          for (let i = 0; i < 4; i++) {
            ctx.fillRect(x - barrierWidth / 2 + i * stripeSpacing, this.y - barrierHeight / 2, stripeWidth, barrierHeight);
          }
        } else {
          // Traffic cone with perspective scaling
          const coneHeight = 30 * scale;
          const coneWidth = 24 * scale;
          ctx.shadowColor = '#ff4400';
          ctx.shadowBlur = 10 * scale;
          ctx.fillStyle = '#ff4400';
          ctx.beginPath();
          ctx.moveTo(x, this.y - coneHeight / 2);
          ctx.lineTo(x - coneWidth / 2, this.y + coneHeight / 3);
          ctx.lineTo(x + coneWidth / 2, this.y + coneHeight / 3);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(x - coneWidth / 3, this.y - 5 * scale, coneWidth * 0.66, 5 * scale);
        }
        ctx.restore();
      }
      checkCollision(playerLane, playerY) {
        if (this.lane !== playerLane) return false;
        const dist = Math.abs(this.y - playerY);
        return dist < 35;
      }
    }

    class RivalCar {
      constructor() {
        this.lane = randInt(0, 2);
        this.y = -80;
        this.width = 40;
        this.height = 70;
        this.speed = level3Params.roadSpeed * 0.7; // slower than road
        this.wobbleTimer = 0;
        this.targetLane = this.lane;
        this.laneProgress = this.lane; // Fractional lane position for smooth transitions
      }
      update(deltaSec) {
        this.y += this.speed * speedMultiplier * drivingSpeed * deltaSec;

        // Occasionally change lanes
        this.wobbleTimer -= deltaSec;
        if (this.wobbleTimer <= 0) {
          this.wobbleTimer = randRange(1.5, 3);
          if (Math.random() < 0.4) {
            this.targetLane = clamp(this.lane + (Math.random() < 0.5 ? -1 : 1), 0, 2);
          }
        }

        // Smooth lane transition using fractional lane position
        this.laneProgress += (this.targetLane - this.laneProgress) * 3 * deltaSec;
        if (Math.abs(this.laneProgress - this.targetLane) < 0.05) this.lane = this.targetLane;

        return this.y < canvas.height + 100;
      }
      draw() {
        // Get perspective-correct position and scale using fractional lane
        const persp = getPerspective(this.laneProgress, this.y);
        const x = persp.x;
        const scale = persp.scale;

        ctx.save();
        // Car body with perspective scaling
        const carWidth = 36 * scale;
        const carHeight = 60 * scale;
        ctx.shadowColor = '#ff3366';
        ctx.shadowBlur = 15 * scale;
        ctx.fillStyle = '#cc2255';
        ctx.fillRect(x - carWidth / 2, this.y - carHeight / 2, carWidth, carHeight);

        // Windshield
        const windshieldWidth = 24 * scale;
        const windshieldHeight = 18 * scale;
        ctx.fillStyle = '#333355';
        ctx.fillRect(x - windshieldWidth / 2, this.y - carHeight / 3, windshieldWidth, windshieldHeight);

        // Rear lights
        const lightWidth = 8 * scale;
        const lightHeight = 6 * scale;
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 8 * scale;
        ctx.fillRect(x - carWidth / 2 + 2 * scale, this.y + carHeight / 3, lightWidth, lightHeight);
        ctx.fillRect(x + carWidth / 2 - lightWidth - 2 * scale, this.y + carHeight / 3, lightWidth, lightHeight);
        ctx.restore();
      }
      checkCollision(playerLane, playerY) {
        const persp = getPerspective(this.laneProgress, this.y);
        const playerPersp = getPerspective(playerLane, playerY);
        const dx = Math.abs(persp.x - playerPersp.x);
        const dy = Math.abs(this.y - playerY);
        return dx < 35 * persp.scale && dy < 45;
      }
    }

    class PoliceBoss {
      constructor() {
        this.cfg = bossConfigs[3];
        this.lane = 1;
        this.x = getLaneX(1);
        this.y = canvas.height * 0.3;
        this.maxHp = this.cfg.hp;
        this.hp = this.cfg.hp;
        this.width = 45;
        this.height = 80;
        this.actionTimer = 0;
        this.sirenPhase = 0;
        this.chargeTimer = 0;
        this.isCharging = false;
        this.invulnerable = 0;
      }
      update(deltaSec) {
        this.sirenPhase += deltaSec * 8;
        this.invulnerable = Math.max(0, this.invulnerable - deltaSec);

        // AI behavior
        this.actionTimer -= deltaSec;
        if (this.actionTimer <= 0) {
          this.actionTimer = randRange(0.8, 1.5);

          // Randomly change lanes or charge
          if (Math.random() < 0.3 && !this.isCharging) {
            this.isCharging = true;
            this.chargeTimer = 0.6;
          } else {
            const newLane = clamp(this.lane + (Math.random() < 0.5 ? -1 : 1), 0, 2);
            this.lane = newLane;
          }
        }

        // Handle charging
        if (this.isCharging) {
          this.chargeTimer -= deltaSec;
          this.y += 300 * deltaSec;
          if (this.chargeTimer <= 0) {
            this.isCharging = false;
            this.y = canvas.height * 0.3;
          }
        }

        // Smooth movement to target lane
        const targetX = getLaneX(this.lane);
        this.x += (targetX - this.x) * 5 * deltaSec;
      }
      draw() {
        ctx.save();

        // Police car body
        ctx.shadowColor = '#4444ff';
        ctx.shadowBlur = 20;
        ctx.fillStyle = '#222244';
        ctx.fillRect(this.x - 22, this.y - 35, 44, 70);

        // White stripe
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x - 22, this.y - 10, 44, 8);

        // Windshield
        ctx.fillStyle = '#111122';
        ctx.fillRect(this.x - 16, this.y - 25, 32, 20);

        // Siren lights (alternating)
        const sirenColor1 = Math.sin(this.sirenPhase) > 0 ? '#ff0000' : '#440000';
        const sirenColor2 = Math.sin(this.sirenPhase) > 0 ? '#440044' : '#0000ff';
        ctx.fillStyle = sirenColor1;
        ctx.shadowColor = sirenColor1;
        ctx.shadowBlur = 15;
        ctx.fillRect(this.x - 18, this.y - 40, 14, 8);
        ctx.fillStyle = sirenColor2;
        ctx.shadowColor = sirenColor2;
        ctx.fillRect(this.x + 4, this.y - 40, 14, 8);

        // Boss health bar
        const barW = 200, barH = 10, barX = canvas.width / 2 - barW / 2, barY = 20;
        ctx.shadowBlur = 0;
        ctx.strokeStyle = this.cfg.bar;
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barW, barH);
        const frac = clamp(this.hp / this.maxHp, 0, 1);
        ctx.fillStyle = this.cfg.bar;
        ctx.fillRect(barX, barY, barW * frac, barH);

        // "POLICE" text
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('POLICE', this.x, this.y + 5);

        ctx.restore();
      }
      checkPlayerCollision(playerLane, playerY) {
        const playerX = getLaneX(playerLane);
        const dx = Math.abs(this.x - playerX);
        const dy = Math.abs(this.y - playerY);
        return dx < 40 && dy < 50;
      }
      checkObstacleHit(obstacle) {
        if (this.invulnerable > 0) return false;
        const dx = Math.abs(getLaneX(obstacle.lane) - this.x);
        const dy = Math.abs(obstacle.y - this.y);
        if (dx < 35 && dy < 40) {
          this.hp--;
          this.invulnerable = 0.5;
          return true;
        }
        return false;
      }
    }

    // Starfield for Level 4
    let stars = [];
    function initStars() {
      const count = Math.floor((canvas.width*canvas.height)/25000);
      stars = Array.from({length: count}, () => ({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        z: Math.random()*2 + 0.5
      }));
    }
    function drawSpaceBG(deltaSec) {
      ctx.fillStyle = '#000015'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#9fe6ff';
      stars.forEach(s => {
        s.y += 40*s.z*speedMultiplier*deltaSec;
        if (s.y > canvas.height) { s.y = 0; s.x = Math.random()*canvas.width; s.z = Math.random()*2 + 0.5; }
        ctx.fillRect(s.x, s.y, s.z, s.z);
      });
      // subtle nebula
      const g = ctx.createRadialGradient(canvas.width*0.7, canvas.height*0.3, 10, canvas.width*0.7, canvas.height*0.3, canvas.width*0.6);
      g.addColorStop(0,'rgba(120,200,255,0.15)'); g.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // ===== Game loop =====
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaMs = timestamp - lastTime;
      const dt = deltaMs / (1000 / 60);   // normalized (60fps)
      const deltaSec = deltaMs / 1000;    // real seconds
      lastTime = timestamp;

      // Background per-level
      if (currentMode === Modes.CANYON) drawCanyon();
      else if (currentMode === Modes.BATS) drawBatCaveBG();
      else if (currentMode === Modes.DRIVING) drawHighwayBG(deltaSec);
      else if (currentMode === Modes.ALIENS) drawSpaceBG(deltaSec);

      if (gameRunning) {
        if (currentMode === Modes.CANYON) {
          // Stable spawns (Poisson)
          const lp = level1Params;
          const reloadFactor = isReloading ? 0.35 : 1.0;
          if (!boss && !levelCleared) {
            const lambda = lp.spawnPerSec * reloadFactor * speedMultiplier;
            const spawnProb = 1 - Math.exp(-lambda * deltaSec);
            if (Math.random() < spawnProb) targets.push(new Target(lp));
          }

          const chestLambda = coinChestSpawnRates.canyon * reloadFactor * speedMultiplier;
          const chestProb = 1 - Math.exp(-chestLambda * deltaSec);
          if (Math.random() < chestProb) coinChests3D.push(new CoinChest3D(lp));

          // Draw far-to-near (bigger z first)
          const combined = [
            ...targets.map(entity => ({ entity, type: 'target' })),
            ...coinChests3D.map(entity => ({ entity, type: 'chest' }))
          ];
          combined.sort((a, b) => b.entity.z - a.entity.z);
          const newTargets = [];
          const newChests = [];
          combined.forEach(item => {
            const alive = item.entity.update(dt);
            if (!alive) return;
            item.entity.draw();
            if (item.type === 'target') newTargets.push(item.entity);
            else newChests.push(item.entity);
          });
          targets = newTargets;
          coinChests3D = newChests;
          explosions = explosions.filter(ex => { const alive = ex.update(dt); if (alive) ex.draw(); return alive; });

          // Boss (Level 1 canyon) — update and render above the canyon backdrop
          if (boss) {
            boss.update(deltaSec);
            boss.draw();
          }

      } else if (currentMode === Modes.DRIVING) {
        // ==== DRIVING MODE (Level 3 - Neon Highway) ====
        const playerY = canvas.height - 80;

        // Spawn answer gates on timer
        if (!boss && !levelCleared) {
          gateSpawnTimer -= deltaSec;
          if (gateSpawnTimer <= 0 && questionIndex[level] < levelQuestions[level].length) {
            gateSpawnTimer = level3Params.gateSpawnInterval;
            const problem = levelQuestions[level][questionIndex[level]];
            const correctAnswer = problem.answer;
            const correctLane = randInt(0, 2);

            // Generate wrong answers
            const answers = [];
            for (let i = 0; i < 3; i++) {
              if (i === correctLane) {
                answers.push(correctAnswer);
              } else {
                // Generate a plausible wrong answer
                let wrong = correctAnswer + randInt(-15, 15);
                while (wrong === correctAnswer || wrong <= 0 || answers.includes(wrong)) {
                  wrong = correctAnswer + randInt(-20, 20);
                  if (wrong <= 0) wrong = correctAnswer + randInt(1, 10);
                }
                answers.push(wrong);
              }
            }
            // Clear obstacles when gate spawns for clear road
            roadObstacles = [];
            rivalCars = [];
            answerGates.push(new AnswerGate(answers, correctLane, problem));
          }
        }

        // Spawn obstacles only when no gates are on screen
        const gateOnScreen = answerGates.length > 0;
        if (!boss && !levelCleared && !gateOnScreen) {
          const obstacleProb = 1 - Math.exp(-level3Params.obstacleSpawnRate * speedMultiplier * deltaSec);
          if (Math.random() < obstacleProb) {
            roadObstacles.push(new RoadObstacle());
          }
          const rivalProb = 1 - Math.exp(-level3Params.rivalCarRate * speedMultiplier * deltaSec);
          if (Math.random() < rivalProb) {
            rivalCars.push(new RivalCar());
          }
        }

        // Update and draw driving bullets
        drivingBullets = drivingBullets.filter(bullet => {
          const alive = bullet.update(deltaSec);
          if (!alive) return false;
          bullet.draw();
          return true;
        });

        // Update and draw obstacles
        roadObstacles = roadObstacles.filter(ob => {
          const alive = ob.update(deltaSec);
          if (!alive) return false;
          ob.draw();

          // Check if bullet hits obstacle
          for (let i = drivingBullets.length - 1; i >= 0; i--) {
            if (drivingBullets[i].checkHit(ob.y, ob.lane)) {
              drivingBullets.splice(i, 1);
              score += 25;
              explosions.push(new Explosion(getLaneX(ob.lane), ob.y));
              updateUI();
              return false;
            }
          }

          // Check collision with player
          if (ob.checkCollision(drivingLane, playerY)) {
            health -= level3Params.obstacleDamage;
            updateUI();
            explosions.push(new Explosion(getLaneX(drivingLane), playerY));
            return false;
          }

          return true;
        });

        // Update and draw rival cars
        rivalCars = rivalCars.filter(car => {
          const alive = car.update(deltaSec);
          if (!alive) return false;
          car.draw();

          // Check if bullet hits car
          for (let i = drivingBullets.length - 1; i >= 0; i--) {
            const bullet = drivingBullets[i];
            const dx = Math.abs(bullet.x - car.x);
            const dy = Math.abs(bullet.y - car.y);
            if (dx < 30 && dy < 40) {
              drivingBullets.splice(i, 1);
              score += 50;
              explosions.push(new Explosion(car.x, car.y));
              updateUI();
              return false;
            }
          }

          // Check collision with player
          if (car.checkCollision(drivingLane, playerY)) {
            health -= level3Params.obstacleDamage;
            updateUI();
            explosions.push(new Explosion(getLaneX(drivingLane), playerY));
            return false;
          }
          return true;
        });

        // Update and draw answer gates
        answerGates = answerGates.filter(gate => {
          const alive = gate.update(deltaSec);
          if (!alive) return false;
          gate.draw();

          // Check if player passed through a gate
          const result = gate.checkCollision(drivingLane, playerY);
          if (result !== null) {
            if (result === true) {
              // Correct answer!
              score += 100;
              correctThisLevel++;
              questionIndex[level]++;
              drivingSpeed = Math.min(1.8, drivingSpeed + 0.05);
              showBanner('Correct!', 600);

              if (correctThisLevel >= levelGoal && !boss && !levelCleared) {
                spawnDrivingBoss();
              }
            } else {
              // Wrong answer
              health -= level3Params.wrongAnswerDamage;
              drivingSpeed = Math.max(0.6, drivingSpeed - 0.1);
              showBanner('Wrong!', 600);
            }
            updateUI();
            return false;
          }
          return true;
        });

        // Police boss update
        if (boss) {
          boss.update(deltaSec);
          boss.draw();

          // Check if bullets hit boss
          for (let i = drivingBullets.length - 1; i >= 0; i--) {
            if (drivingBullets[i].checkHitBoss(boss)) {
              drivingBullets.splice(i, 1);
              if (boss.invulnerable <= 0) {
                boss.hp--;
                boss.invulnerable = 0.3;
                score += 40;
                explosions.push(new Explosion(boss.x, boss.y));
                updateUI();
              }
            }
          }

          // Check if boss collides with player
          if (boss.checkPlayerCollision(drivingLane, playerY)) {
            health -= 15;
            updateUI();
            explosions.push(new Explosion(getLaneX(drivingLane), playerY));
          }

          // Check if boss HP depleted
          if (boss.hp <= 0) {
            const defeatedX = boss.x;
            const defeatedY = boss.y;
            boss = null;
            handleBossDefeated(3, defeatedX, defeatedY);
          }
        }

        // Draw explosions
        explosions = explosions.filter(ex => { const alive = ex.update(dt); if (alive) ex.draw(); return alive; });

      } else {
        // ==== 2D mode update (BATS, ALIENS) ====
          // Spawn by level
          let spawnPerSec = (currentMode===Modes.BATS?level2Params.spawnPerSec:level4Params.spawnPerSec);
          const reloadFactor = isReloading ? 0.35 : 1.0;
          const lambda = spawnPerSec * reloadFactor * speedMultiplier;
          const spawnProb = 1 - Math.exp(-lambda * deltaSec);

          const chestLambda = coinChestSpawnRates.twoD * reloadFactor * speedMultiplier;
          const chestProb = 1 - Math.exp(-chestLambda * deltaSec);
          if (Math.random() < chestProb) coinChests2D.push(new CoinChest2D(currentMode));

          if (!boss && !levelCleared) { // while boss alive or level cleared we stop adding more enemies
            if (Math.random() < spawnProb) {
              if (currentMode === Modes.BATS) enemies2D.push(new Bat());
              else if (currentMode === Modes.ALIENS) enemies2D.push(new Alien());
            }
          }

          coinChests2D = coinChests2D.filter(ch => {
            if (ch.mode !== currentMode) return false;
            const alive = ch.update(deltaSec);
            if (!alive) return false;
            ch.draw();
            for (let i=0;i<projectiles.length;i++) {
              const b = projectiles[i];
              if (ch.hitTest(b.x, b.y, b.r)) {
                projectiles.splice(i,1);
                grantChestCoins(ch.x, ch.y);
                return false;
              }
            }
            return true;
          });

          // Player motion (keyboard or mouse X) — ship speed is not slowed
          const move = (player.moveRight ? 1 : 0) - (player.moveLeft ? 1 : 0);
          player.x += move * player.speed * deltaSec;
          clampPlayer();

          // Update bullets
          projectiles = projectiles.filter(b => { const alive = b.update(deltaSec); if (alive) b.draw(); return alive; });

          // Collisions: bullets vs enemies
          enemies2D = enemies2D.filter(en => {
            // move enemy
            const alive = en.update(deltaSec);
            if (!alive) return false;

            // draw enemy
            en.draw();

            // collide with player row (bonus: grazing not required since damage handled on update)

            // bullets hit
            for (let i=0;i<projectiles.length;i++){
              const b = projectiles[i];
              if (en.hitTest(b.x, b.y, b.r)) {
                en.hp -= b.damage ?? 1; score += 25; // per-hit score
                projectiles.splice(i,1);
                explosions.push(new Explosion(en.x || en.x0 || b.x, en.y || b.y));
                break;
              }
            }
            return en.hp > 0;
          });

          // Boss update/draw/hit
          if (boss) {
            boss.update(deltaSec);
            boss.draw();
            // bullets vs boss
            for (let i=0;i<projectiles.length;i++){
              const b = projectiles[i];
              if (boss.hitTest(b.x, b.y, b.r)) {
                boss.hp -= b.damage ?? 1; score += 40;
                projectiles.splice(i,1);
                explosions.push(new Explosion(boss.x, boss.y));
                break;
              }
            }
          }

          if (boss && boss.hp <= 0) {
            const defeatedLevel = boss.level;
            const defeatedX = boss.x;
            const defeatedY = boss.y;
            boss = null;
            handleBossDefeated(defeatedLevel, defeatedX, defeatedY);
          }

          // Draw explosions
          explosions = explosions.filter(ex => { const alive = ex.update(dt); if (alive) ex.draw(); return alive; });
        }

        if (!heartSpawnActive && health < 40) { heartSpawnActive = true; heartSpawnTimer = 0; }
        if (heartSpawnActive) {
          heartSpawnTimer -= deltaSec;
          if (heartSpawnTimer <= 0) {
            hearts.push(new Heart());
            heartSpawnTimer = heartSpawnInterval;
          }
          if (health >= 75) heartSpawnActive = false;
        }

        hearts = hearts.filter(h => {
          const alive = h.update(deltaSec);
          if (!alive) return false;
          h.draw();

          // Driving mode: car collects hearts by driving into them
          if (currentMode === Modes.DRIVING) {
            const playerY = canvas.height - 80;
            // Check if heart is in same lane and close enough vertically
            if (h.lane === drivingLane && Math.abs(h.y - playerY) < 50) {
              health = Math.min(100, health + 10);
              updateUI();
              explosions.push(new Explosion(h.x, h.y));
              return false;
            }
          } else if (currentMode !== Modes.CANYON) {
            for (let i=0;i<projectiles.length;i++) {
              const b = projectiles[i];
              if (h.hitTest(b.x, b.y, b.r)) {
                projectiles.splice(i,1);
                health = Math.min(100, health + 10);
                updateUI();
                return false;
              }
            }
          }
          return true;
        });
      }

      bossDefeatFx = bossDefeatFx.filter(fx => { const alive = fx.update(deltaSec); fx.draw(); return alive; });

      // Reticle, ship, or car
      if (currentMode === Modes.CANYON) drawCrosshair();
      else if (currentMode === Modes.DRIVING) drawPlayerCar();
      else drawShip();

      requestAnimationFrame(gameLoop);
    }

    function drawCrosshair() {
      boomgunAim = null;
      ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 5;
      ctx.beginPath(); ctx.arc(mouseX, mouseY, 15, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(mouseX - 20, mouseY); ctx.lineTo(mouseX - 10, mouseY);
      ctx.moveTo(mouseX + 10, mouseY); ctx.lineTo(mouseX + 20, mouseY);
      ctx.moveTo(mouseX, mouseY - 20); ctx.lineTo(mouseX, mouseY - 10);
      ctx.moveTo(mouseX, mouseY + 10); ctx.lineTo(mouseX, mouseY + 20);
      ctx.stroke(); ctx.shadowBlur = 0;

      if (currentWeapon === 'x2boomgun' && currentMode === Modes.CANYON && targets.length) {
        let best = null;
        let bestDist = Infinity;
        for (const target of targets) {
          const coords = target.getScreenCoords();
          const dist = Math.hypot(mouseX - coords.x, mouseY - coords.y);
          if (dist < bestDist) {
            bestDist = dist;
            best = { target, coords };
          }
        }

        if (best) {
          const { target, coords } = best;
          const activationRadius = coords.size * 4 + 80;
          if (bestDist <= activationRadius) {
            boomgunAim = { target, x: coords.x, y: coords.y, size: coords.size };
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 60, 60, 0.95)';
            ctx.lineWidth = 2.5;
            ctx.shadowColor = '#ff3333';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.moveTo(mouseX, mouseY);
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
            ctx.lineWidth = 3;
            const boxSize = coords.size * 2;
            ctx.strokeRect(coords.x - coords.size, coords.y - coords.size, boxSize, boxSize);
            ctx.restore();
          }
        }
      }
    }

    // ===== Events =====
    function destroyTarget(target, hitX, hitY) {
      if (!target) return;
      const idx = targets.indexOf(target);
      if (idx === -1) return;
      const scoreGain = Math.floor(100 / Math.max(1, target.z) * 10);
      score += scoreGain;
      explosions.push(new Explosion(hitX, hitY));
      targets.splice(idx, 1);
      updateUI();
    }

    function fireHitscanShots(shots) {
      if (!Array.isArray(shots)) return;
      shots.forEach(shot => {
        let remaining = shot && shot.pierce ? shot.pierce : 1;
        if (!shot) return;

        if (hearts.length) {
          for (let i = hearts.length - 1; i >= 0; i--) {
            if (hearts[i].hitTest(shot.x, shot.y)) {
              hearts.splice(i, 1);
              health = Math.min(100, health + 10);
              updateUI();
              remaining = 0;
              break;
            }
          }
        }

        if (remaining > 0 && coinChests3D.length) {
          for (let i = coinChests3D.length - 1; i >= 0; i--) {
            const chest = coinChests3D[i];
            if (chest.checkHit(shot.x, shot.y)) {
              const coords = chest.getScreenCoords();
              grantChestCoins(coords.x, coords.y);
              coinChests3D.splice(i, 1);
              remaining = 0;
              break;
            }
          }
        }

        if (remaining > 0 && boss && boss.hitTest(shot.x, shot.y)) {
          boss.hp -= shot.damage ?? 1; score += 40;
          explosions.push(new Explosion(boss.x, boss.y));
          remaining = 0;
          if (boss.hp <= 0) {
            const defeatedLevel = boss.level;
            const defeatedX = boss.x;
            const defeatedY = boss.y;
            boss = null;
            handleBossDefeated(defeatedLevel, defeatedX, defeatedY);
          }
        }

        while (remaining > 0) {
          const sorted = [...targets].sort((a, b) => a.z - b.z);
          let hit = false;
          for (let t of sorted) {
            if (t.checkHit(shot.x, shot.y)) {
              destroyTarget(t, shot.x, shot.y);
              remaining--;
              hit = true;
              break;
            }
          }
          if (!hit) break;
        }
      });
    }

    function activateNuke() {
      if (!gameRunning || nukeCount <= 0) return;
      nukeCount--;
      const blastCount = 12;
      for (let i = 0; i < blastCount; i++) {
        const exX = Math.random() * canvas.width;
        const exY = Math.random() * canvas.height;
        explosions.push(new Explosion(exX, exY));
      }
      targets = [];
      enemies2D = [];
      projectiles = [];
      hearts = [];
      coinChests3D = [];
      coinChests2D = [];
      answerGates = [];
      roadObstacles = [];
      rivalCars = [];
      drivingBullets = [];
      if (boss) { boss.hp = 0; }
      updateUI();
    }

    function purchaseItem(item) {
      if (!item) return;
      if (item.type === 'nuke') {
        if (coins < item.cost) return;
        coins -= item.cost;
        nukeCount++;
        updateUI();
        renderShop();
        return;
      }

      if (ownedWeapons.has(item.id) || coins < item.cost) return;
      coins -= item.cost;
      ownedWeapons.add(item.id);
      currentWeapon = item.id;
      updateUI();
      renderShop();
    }

    function equipWeapon(id) {
      if (!ownedWeapons.has(id)) return;
      currentWeapon = id;
      updateUI();
      renderShop();
    }

    function renderShop() {
      shopCoinsEl.textContent = `Coins: ${coins}`;
      shopItemsEl.innerHTML = '';
      shopItems.forEach(item => {
        const wrapper = document.createElement('div');
        wrapper.className = 'item';
        const header = document.createElement('header');
        const nameSpan = document.createElement('span');
        nameSpan.textContent = item.name;
        const costSpan = document.createElement('span');
        costSpan.textContent = `${item.cost} coins`;
        header.appendChild(nameSpan);
        header.appendChild(costSpan);
        const desc = document.createElement('p');
        desc.textContent = item.description;
        const btn = document.createElement('button');

        if (item.type === 'nuke') {
          btn.textContent = 'Buy Nuke';
          btn.disabled = coins < item.cost;
          btn.addEventListener('click', () => purchaseItem(item));
        } else {
          const owned = ownedWeapons.has(item.id);
          if (!owned) {
            btn.textContent = `Buy for ${item.cost}`;
            btn.disabled = coins < item.cost;
            btn.addEventListener('click', () => purchaseItem(item));
          } else if (currentWeapon === item.id) {
            btn.textContent = 'Equipped';
            btn.disabled = true;
          } else {
            btn.textContent = 'Equip';
            btn.disabled = false;
            btn.addEventListener('click', () => equipWeapon(item.id));
          }
        }

        wrapper.appendChild(header);
        wrapper.appendChild(desc);
        wrapper.appendChild(btn);
        shopItemsEl.appendChild(wrapper);
      });
    }

    function openShop() {
      gameRunning = false;
      isPaused = false;
      pauseScreen.style.display = 'none';
      mathPrompt.style.display = 'none';
      isReloading = false;
      renderShop();
      shopScreen.style.display = 'block';
    }

    function closeShop() {
      shopScreen.style.display = 'none';
      if (pendingLevel) {
        configureLevel(pendingLevel);
        bullets = bulletsPerReloadForLevel(pendingLevel);
        correctThisLevel = 0;
        updateUI();
        showBanner(`Level ${pendingLevel}: ${levelOps[pendingLevel].name}`);
        pendingLevel = null;
      } else {
        updateUI();
      }
      gameRunning = true;
    }

    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX; mouseY = e.clientY;
      if (currentMode !== Modes.CANYON) { player.x = e.clientX; clampPlayer(); }
    });

    // Shooting
    function tryShoot() {
      if (!gameRunning || isReloading) return;

      // Driving mode: fire driving bullets (no ammo cost, free shooting)
      if (currentMode === Modes.DRIVING) {
        drivingBullets.push(new DrivingBullet(drivingLane));
        return;
      }

      const weapon = weaponCatalog[currentWeapon] || weaponCatalog.blaster;
      const bulletCost = weapon.bulletCost ?? 1;
      if (bullets < bulletCost) { showMathPrompt(); return; }
      bullets -= bulletCost;
      updateUI();

      if (currentMode === Modes.CANYON) {
        if (weapon.id === 'x2boomgun' && boomgunAim && targets.includes(boomgunAim.target)) {
          destroyTarget(boomgunAim.target, boomgunAim.x, boomgunAim.y);
        }
        const shots = weapon.hitscanShots ? weapon.hitscanShots(mouseX, mouseY) : [{ x: mouseX, y: mouseY, pierce: 1 }];
        fireHitscanShots(shots);
      } else {
        const projs = weapon.projectiles ? weapon.projectiles(player) : [new Bullet({ x: player.x, y: player.y + (player.bulletDir > 0 ? 12 : -12), dir: player.bulletDir })];
        projs.forEach(p => projectiles.push(p));
      }

      if (bullets === 0) showMathPrompt();
    }

    canvas.addEventListener('click', tryShoot);

    mathAnswerEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') checkAnswer(); });
    answerBtn.addEventListener('click', checkAnswer);

    restartBtn1.addEventListener('click', () => { startScreen.style.display='none'; restartGame(); });
    restartBtn2.addEventListener('click', () => { startScreen.style.display='none'; restartGame(); });

    resumeBtn.addEventListener('click', togglePause);
    useNukeBtn.addEventListener('click', activateNuke);
    shopContinueBtn.addEventListener('click', closeShop);

    speedSlider.addEventListener('input', () => { syncSpeedFromSlider(); });

    window.addEventListener('resize', resize);

    // Keyboard controls for ship levels
    window.addEventListener('keydown', (e) => {
      if ((e.key === 'a' || e.key === 'A') && !e.repeat) {
        if (gameRunning && shopScreen.style.display === 'none' && currentMode !== Modes.DRIVING) {
          e.preventDefault();
          openShop();
          player.moveLeft = false;
          player.moveRight = false;
          return;
        }
      }

      // Driving mode: lane switching with arrow keys or A/D
      if (currentMode === Modes.DRIVING && gameRunning && !e.repeat) {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          drivingLane = Math.max(0, drivingLane - 1);
          e.preventDefault();
          return;
        }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          drivingLane = Math.min(2, drivingLane + 1);
          e.preventDefault();
          return;
        }
      }

      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') player.moveLeft = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') player.moveRight = true;
      if (e.key === ' ') { e.preventDefault(); tryShoot(); }
      if ((e.key === 'p' || e.key === 'P') && !e.repeat) togglePause();
      if ((e.key === 'n' || e.key === 'N') && !e.repeat) activateNuke();
      if (!gameRunning && e.key === 'Enter' && startScreen.style.display !== 'none') startBtn.click();
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') player.moveLeft = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') player.moveRight = false;
    });

    // Start screen button
    startBtn.addEventListener('click', () => {
      startScreen.style.display = 'none';
      restartGame();
    });

    // ===== Level configuration =====
    function configureLevel(lvl) {
      // Switch interaction mode + background helpers
      if (lvl === 1) {
        currentMode = Modes.CANYON;
        document.body.classList.remove('ship-mode');
        canvas.style.cursor = 'crosshair';
      } else if (lvl === 2) {
        currentMode = Modes.BATS;
        document.body.classList.add('ship-mode');
        canvas.style.cursor = 'none';
        enemies2D = []; projectiles = []; explosions = []; boss = null;
        player.topMode = false; player.bulletDir = -1; clampPlayer();
      } else if (lvl === 3) {
        currentMode = Modes.DRIVING;
        document.body.classList.add('ship-mode');
        canvas.style.cursor = 'none';
        enemies2D = []; projectiles = []; explosions = []; boss = null;
        answerGates = []; roadObstacles = []; rivalCars = []; drivingBullets = [];
        drivingLane = 1; roadScrollOffset = 0; gateSpawnTimer = 0;
        drivingSpeed = 1.0; activeGateProblem = null;
        initRoadLines();
      } else {
        currentMode = Modes.ALIENS;
        document.body.classList.add('ship-mode');
        enemies2D = []; projectiles = []; explosions = []; boss = null;
        player.topMode = false; player.bulletDir = -1; clampPlayer();
        initStars();
      }
      levelCleared = false;
      bossDefeatFx = [];
      coinChests3D = [];
      coinChests2D = [];
      shuffleQuestionsForLevel(lvl);
      questionIndex[lvl] = 0;
      const overrideGoal = levelGoalOverrides[lvl];
      levelGoal = overrideGoal ?? levelQuestions[lvl].length;
      levelEl.textContent = lvl;
      levelGoalEl.textContent = levelGoal;
      promptTitle.textContent = `RELOAD — Level ${lvl}: ${levelOps[lvl].name}`;
    }

    function spawnBoss(lvl) {
      boss = new Boss(lvl);
      showBanner(`LEVEL ${lvl} BOSS!`, 1600);
    }

    function spawnDrivingBoss() {
      boss = new PoliceBoss();
      answerGates = []; // Clear any remaining gates
      showBanner('POLICE CHASE!', 1600);
    }

    // ===== Start =====
    initDecor();
    initStars();
    syncSpeedFromSlider(); // ensure slider value applies
    updateUI();
    requestAnimationFrame(gameLoop);
    // Leave title showing; game begins when Start is clicked.
  </script>
</body>
</html>
